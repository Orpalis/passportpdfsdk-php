<?php
/**
 * ImageApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PassportPDF API
 *
 * Introduction:    PassportPDF API is a REST API that lets you perform complex operations on documents and images easily.  You may consume the API by using our.NET SDK (other platforms / languages are soon to come), or any REST client by sending your requests to the appropriate endpoints.   A list of all the available endpoints can be found on the API reference page at https://passportpdfapi.com/references/api/index.html        Authentication:    Each available operation has a predefined cost, expressed as a number of tokens.  These tokens are deducted from your \"passport,\" which has a unique identifier that acts as an API key. This key is, therefore, required to be provided with each request for the latter to be honored(except if the operation does not have a cost, typically when you request a simple data with a GET).  Your key must be included in the header of the request, under the name \"X-PassportPdf-API-Key.\"  If you are using the.NET SDK, you can either set your key in the ApiKey property of your API instance(PdfApi or ImageApi, for example) or set it globally in the GlobalConfiguration instance if you want to set it once for the whole life cycle of your application.          Communication with the API:    All the available actions are listed on the API reference page, as previously mentioned.  There are several different controllers, i.e., routes, which categorize the actions.For example, you may use the PDF controller(\"/api/pdf\" route) to perform PDF - related operations, and the Image controller(\"/api/image\") for images.  Each action defines what kind of parameters(if any) is expected, and what kind of response is served.Parameters and responses are represented using data models, or \"schemas,\" and are listed in the \"Schemas\" section of the reference.   Parameters and response models of a given action are both prefixed by the controller name, the action name, and \"Parameters\" / \"Response,\" e.g. \"api/pdf/reduce\" respectively receives and serves a PdfReduceParameters and PdfReduceResponse models.  Using the .NET SDK, you will find the objects to interact with the different controllers in the PassportPDF.Api namespace and all the schemas in the PassportPDF.Model namespace.        Processing documents:    Each document manipulation starts with importing the file onto the API.  The LoadDocument action of the PDF controller lets you import your document as a PDF.  Note that the GetPDFImportSupportedFileExtensions action of the same controller will let you know all the different types of files that you may import as a PDF. LoadDocument responds with a JSON-serialized PdfLoadDocumentResponse model, which contains a \"FileId\" property.This identifier is required for the API to know about your document for further manipulations, hence the presence of a \"FileId\" property in the PdfReduceParameters schema (and many other parameters schemas). To download the changes made to a file, you need, of course, to download the new version of the file from the API.  To save your document as a PDF, you will need to use the SaveDocument action of the PDF controller and provide a PdfSaveDocumentParameters data model that contains the identifier of your file.        Errors:    Conventional HTTP response codes are used to indicate the success or failure of an API request.   The Error data model also defines some information about an error that occurred on the API.   Each response model has an Error in its definition, and its sole existence in the serialized response - which should thus always be checked - indicates that something went wrong.  Among the information given by the Error schema, \"ResultCode\" specifies a value of the \"PassportPDFStatus\" enumeration, that defines a first level of error information. \"InternalErrorId\" defines a unique identifier for the error, which comes very handy for us to troubleshoot any issue you may encounter quickly.        Efficiency considerations:    Multipart upload/download is available and lets you directly stream a file to/from the API.  In the PDF controller, LoadDocument/LoadDocumentMultipart and SaveDocument/SaveDocumentToFile may be used to upload/download a document using respectively binary data serialization and streaming multipart HTTP requests.  The second approach should be favored when dealing with large files, as it will be much more efficient in that context.
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ImageApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ImageApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation imageAdjust
     *
     * Adjusts a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAdjustParameters $image_adjust_parameters An ImageAdjustParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAdjustResponse
     */
    public function imageAdjust($image_adjust_parameters)
    {
        list($response) = $this->imageAdjustWithHttpInfo($image_adjust_parameters);
        return $response;
    }

    /**
     * Operation imageAdjustWithHttpInfo
     *
     * Adjusts a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAdjustParameters $image_adjust_parameters An ImageAdjustParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAdjustResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageAdjustWithHttpInfo($image_adjust_parameters)
    {
        $request = $this->imageAdjustRequest($image_adjust_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageAdjustResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAdjustResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAdjustResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAdjustResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageAdjustAsync
     *
     * Adjusts a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAdjustParameters $image_adjust_parameters An ImageAdjustParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAdjustAsync($image_adjust_parameters)
    {
        return $this->imageAdjustAsyncWithHttpInfo($image_adjust_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageAdjustAsyncWithHttpInfo
     *
     * Adjusts a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAdjustParameters $image_adjust_parameters An ImageAdjustParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAdjustAsyncWithHttpInfo($image_adjust_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageAdjustResponse';
        $request = $this->imageAdjustRequest($image_adjust_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageAdjust'
     *
     * @param  \OpenAPI\Client\Model\ImageAdjustParameters $image_adjust_parameters An ImageAdjustParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageAdjustRequest($image_adjust_parameters)
    {
        // verify the required parameter 'image_adjust_parameters' is set
        if ($image_adjust_parameters === null || (is_array($image_adjust_parameters) && count($image_adjust_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_adjust_parameters when calling imageAdjust'
            );
        }

        $resourcePath = '/api/image/ImageAdjust';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_adjust_parameters)) {
            $_tempBody = $image_adjust_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageAutoCrop
     *
     * Automatically crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAutoCropParameters $image_auto_crop_parameters An ImageAutoCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAutoCropResponse
     */
    public function imageAutoCrop($image_auto_crop_parameters)
    {
        list($response) = $this->imageAutoCropWithHttpInfo($image_auto_crop_parameters);
        return $response;
    }

    /**
     * Operation imageAutoCropWithHttpInfo
     *
     * Automatically crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAutoCropParameters $image_auto_crop_parameters An ImageAutoCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAutoCropResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageAutoCropWithHttpInfo($image_auto_crop_parameters)
    {
        $request = $this->imageAutoCropRequest($image_auto_crop_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageAutoCropResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAutoCropResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAutoCropResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAutoCropResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageAutoCropAsync
     *
     * Automatically crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAutoCropParameters $image_auto_crop_parameters An ImageAutoCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAutoCropAsync($image_auto_crop_parameters)
    {
        return $this->imageAutoCropAsyncWithHttpInfo($image_auto_crop_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageAutoCropAsyncWithHttpInfo
     *
     * Automatically crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageAutoCropParameters $image_auto_crop_parameters An ImageAutoCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAutoCropAsyncWithHttpInfo($image_auto_crop_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageAutoCropResponse';
        $request = $this->imageAutoCropRequest($image_auto_crop_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageAutoCrop'
     *
     * @param  \OpenAPI\Client\Model\ImageAutoCropParameters $image_auto_crop_parameters An ImageAutoCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageAutoCropRequest($image_auto_crop_parameters)
    {
        // verify the required parameter 'image_auto_crop_parameters' is set
        if ($image_auto_crop_parameters === null || (is_array($image_auto_crop_parameters) && count($image_auto_crop_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_auto_crop_parameters when calling imageAutoCrop'
            );
        }

        $resourcePath = '/api/image/ImageAutoCrop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_auto_crop_parameters)) {
            $_tempBody = $image_auto_crop_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageCleanupDocument
     *
     * Cleanup a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCleanupDocumentParameters $image_cleanup_document_parameters An ImageCleanupDocumentParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageCleanupDocumentResponse
     */
    public function imageCleanupDocument($image_cleanup_document_parameters)
    {
        list($response) = $this->imageCleanupDocumentWithHttpInfo($image_cleanup_document_parameters);
        return $response;
    }

    /**
     * Operation imageCleanupDocumentWithHttpInfo
     *
     * Cleanup a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCleanupDocumentParameters $image_cleanup_document_parameters An ImageCleanupDocumentParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageCleanupDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageCleanupDocumentWithHttpInfo($image_cleanup_document_parameters)
    {
        $request = $this->imageCleanupDocumentRequest($image_cleanup_document_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageCleanupDocumentResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageCleanupDocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageCleanupDocumentResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageCleanupDocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageCleanupDocumentAsync
     *
     * Cleanup a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCleanupDocumentParameters $image_cleanup_document_parameters An ImageCleanupDocumentParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCleanupDocumentAsync($image_cleanup_document_parameters)
    {
        return $this->imageCleanupDocumentAsyncWithHttpInfo($image_cleanup_document_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageCleanupDocumentAsyncWithHttpInfo
     *
     * Cleanup a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCleanupDocumentParameters $image_cleanup_document_parameters An ImageCleanupDocumentParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCleanupDocumentAsyncWithHttpInfo($image_cleanup_document_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageCleanupDocumentResponse';
        $request = $this->imageCleanupDocumentRequest($image_cleanup_document_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageCleanupDocument'
     *
     * @param  \OpenAPI\Client\Model\ImageCleanupDocumentParameters $image_cleanup_document_parameters An ImageCleanupDocumentParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageCleanupDocumentRequest($image_cleanup_document_parameters)
    {
        // verify the required parameter 'image_cleanup_document_parameters' is set
        if ($image_cleanup_document_parameters === null || (is_array($image_cleanup_document_parameters) && count($image_cleanup_document_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_cleanup_document_parameters when calling imageCleanupDocument'
            );
        }

        $resourcePath = '/api/image/ImageCleanupDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_cleanup_document_parameters)) {
            $_tempBody = $image_cleanup_document_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageCloneRegions
     *
     * Clones regions from a previously uploaded image into new images.
     *
     * @param  \OpenAPI\Client\Model\ImageCloneRegionsParameters $image_clone_regions_parameters An ImageCloneRegionsParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageCloneRegionsResponse
     */
    public function imageCloneRegions($image_clone_regions_parameters)
    {
        list($response) = $this->imageCloneRegionsWithHttpInfo($image_clone_regions_parameters);
        return $response;
    }

    /**
     * Operation imageCloneRegionsWithHttpInfo
     *
     * Clones regions from a previously uploaded image into new images.
     *
     * @param  \OpenAPI\Client\Model\ImageCloneRegionsParameters $image_clone_regions_parameters An ImageCloneRegionsParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageCloneRegionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageCloneRegionsWithHttpInfo($image_clone_regions_parameters)
    {
        $request = $this->imageCloneRegionsRequest($image_clone_regions_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageCloneRegionsResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageCloneRegionsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageCloneRegionsResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageCloneRegionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageCloneRegionsAsync
     *
     * Clones regions from a previously uploaded image into new images.
     *
     * @param  \OpenAPI\Client\Model\ImageCloneRegionsParameters $image_clone_regions_parameters An ImageCloneRegionsParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCloneRegionsAsync($image_clone_regions_parameters)
    {
        return $this->imageCloneRegionsAsyncWithHttpInfo($image_clone_regions_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageCloneRegionsAsyncWithHttpInfo
     *
     * Clones regions from a previously uploaded image into new images.
     *
     * @param  \OpenAPI\Client\Model\ImageCloneRegionsParameters $image_clone_regions_parameters An ImageCloneRegionsParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCloneRegionsAsyncWithHttpInfo($image_clone_regions_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageCloneRegionsResponse';
        $request = $this->imageCloneRegionsRequest($image_clone_regions_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageCloneRegions'
     *
     * @param  \OpenAPI\Client\Model\ImageCloneRegionsParameters $image_clone_regions_parameters An ImageCloneRegionsParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageCloneRegionsRequest($image_clone_regions_parameters)
    {
        // verify the required parameter 'image_clone_regions_parameters' is set
        if ($image_clone_regions_parameters === null || (is_array($image_clone_regions_parameters) && count($image_clone_regions_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_clone_regions_parameters when calling imageCloneRegions'
            );
        }

        $resourcePath = '/api/image/ImageCloneRegions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_clone_regions_parameters)) {
            $_tempBody = $image_clone_regions_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageClose
     *
     * Closes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCloseParameters $image_close_parameters An ImageCloseParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageCloseResponse
     */
    public function imageClose($image_close_parameters)
    {
        list($response) = $this->imageCloseWithHttpInfo($image_close_parameters);
        return $response;
    }

    /**
     * Operation imageCloseWithHttpInfo
     *
     * Closes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCloseParameters $image_close_parameters An ImageCloseParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageCloseResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageCloseWithHttpInfo($image_close_parameters)
    {
        $request = $this->imageCloseRequest($image_close_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageCloseResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageCloseResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageCloseResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageCloseResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageCloseAsync
     *
     * Closes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCloseParameters $image_close_parameters An ImageCloseParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCloseAsync($image_close_parameters)
    {
        return $this->imageCloseAsyncWithHttpInfo($image_close_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageCloseAsyncWithHttpInfo
     *
     * Closes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCloseParameters $image_close_parameters An ImageCloseParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCloseAsyncWithHttpInfo($image_close_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageCloseResponse';
        $request = $this->imageCloseRequest($image_close_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageClose'
     *
     * @param  \OpenAPI\Client\Model\ImageCloseParameters $image_close_parameters An ImageCloseParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageCloseRequest($image_close_parameters)
    {
        // verify the required parameter 'image_close_parameters' is set
        if ($image_close_parameters === null || (is_array($image_close_parameters) && count($image_close_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_close_parameters when calling imageClose'
            );
        }

        $resourcePath = '/api/image/ImageClose';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_close_parameters)) {
            $_tempBody = $image_close_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageConvertColorDepth
     *
     * Converts the color depth of a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageConvertColorDepthParameters $image_convert_color_depth_parameters An ImageConvertColorDepthParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageConvertColorDepthResponse
     */
    public function imageConvertColorDepth($image_convert_color_depth_parameters)
    {
        list($response) = $this->imageConvertColorDepthWithHttpInfo($image_convert_color_depth_parameters);
        return $response;
    }

    /**
     * Operation imageConvertColorDepthWithHttpInfo
     *
     * Converts the color depth of a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageConvertColorDepthParameters $image_convert_color_depth_parameters An ImageConvertColorDepthParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageConvertColorDepthResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageConvertColorDepthWithHttpInfo($image_convert_color_depth_parameters)
    {
        $request = $this->imageConvertColorDepthRequest($image_convert_color_depth_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageConvertColorDepthResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageConvertColorDepthResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageConvertColorDepthResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageConvertColorDepthResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageConvertColorDepthAsync
     *
     * Converts the color depth of a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageConvertColorDepthParameters $image_convert_color_depth_parameters An ImageConvertColorDepthParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageConvertColorDepthAsync($image_convert_color_depth_parameters)
    {
        return $this->imageConvertColorDepthAsyncWithHttpInfo($image_convert_color_depth_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageConvertColorDepthAsyncWithHttpInfo
     *
     * Converts the color depth of a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageConvertColorDepthParameters $image_convert_color_depth_parameters An ImageConvertColorDepthParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageConvertColorDepthAsyncWithHttpInfo($image_convert_color_depth_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageConvertColorDepthResponse';
        $request = $this->imageConvertColorDepthRequest($image_convert_color_depth_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageConvertColorDepth'
     *
     * @param  \OpenAPI\Client\Model\ImageConvertColorDepthParameters $image_convert_color_depth_parameters An ImageConvertColorDepthParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageConvertColorDepthRequest($image_convert_color_depth_parameters)
    {
        // verify the required parameter 'image_convert_color_depth_parameters' is set
        if ($image_convert_color_depth_parameters === null || (is_array($image_convert_color_depth_parameters) && count($image_convert_color_depth_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_convert_color_depth_parameters when calling imageConvertColorDepth'
            );
        }

        $resourcePath = '/api/image/ImageConvertColorDepth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_convert_color_depth_parameters)) {
            $_tempBody = $image_convert_color_depth_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageCrop
     *
     * Crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCropParameters $image_crop_parameters An ImageCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageCropResponse
     */
    public function imageCrop($image_crop_parameters)
    {
        list($response) = $this->imageCropWithHttpInfo($image_crop_parameters);
        return $response;
    }

    /**
     * Operation imageCropWithHttpInfo
     *
     * Crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCropParameters $image_crop_parameters An ImageCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageCropResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageCropWithHttpInfo($image_crop_parameters)
    {
        $request = $this->imageCropRequest($image_crop_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageCropResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageCropResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageCropResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageCropResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageCropAsync
     *
     * Crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCropParameters $image_crop_parameters An ImageCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCropAsync($image_crop_parameters)
    {
        return $this->imageCropAsyncWithHttpInfo($image_crop_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageCropAsyncWithHttpInfo
     *
     * Crops a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageCropParameters $image_crop_parameters An ImageCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageCropAsyncWithHttpInfo($image_crop_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageCropResponse';
        $request = $this->imageCropRequest($image_crop_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageCrop'
     *
     * @param  \OpenAPI\Client\Model\ImageCropParameters $image_crop_parameters An ImageCropParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageCropRequest($image_crop_parameters)
    {
        // verify the required parameter 'image_crop_parameters' is set
        if ($image_crop_parameters === null || (is_array($image_crop_parameters) && count($image_crop_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_crop_parameters when calling imageCrop'
            );
        }

        $resourcePath = '/api/image/ImageCrop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_crop_parameters)) {
            $_tempBody = $image_crop_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageDeletePage
     *
     * Deletes a page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDeletePageParameters $image_delete_page_parameters An ImageDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageDeletePageResponse
     */
    public function imageDeletePage($image_delete_page_parameters)
    {
        list($response) = $this->imageDeletePageWithHttpInfo($image_delete_page_parameters);
        return $response;
    }

    /**
     * Operation imageDeletePageWithHttpInfo
     *
     * Deletes a page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDeletePageParameters $image_delete_page_parameters An ImageDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageDeletePageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageDeletePageWithHttpInfo($image_delete_page_parameters)
    {
        $request = $this->imageDeletePageRequest($image_delete_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageDeletePageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageDeletePageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageDeletePageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageDeletePageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageDeletePageAsync
     *
     * Deletes a page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDeletePageParameters $image_delete_page_parameters An ImageDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDeletePageAsync($image_delete_page_parameters)
    {
        return $this->imageDeletePageAsyncWithHttpInfo($image_delete_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageDeletePageAsyncWithHttpInfo
     *
     * Deletes a page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDeletePageParameters $image_delete_page_parameters An ImageDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDeletePageAsyncWithHttpInfo($image_delete_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageDeletePageResponse';
        $request = $this->imageDeletePageRequest($image_delete_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageDeletePage'
     *
     * @param  \OpenAPI\Client\Model\ImageDeletePageParameters $image_delete_page_parameters An ImageDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageDeletePageRequest($image_delete_page_parameters)
    {
        // verify the required parameter 'image_delete_page_parameters' is set
        if ($image_delete_page_parameters === null || (is_array($image_delete_page_parameters) && count($image_delete_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_delete_page_parameters when calling imageDeletePage'
            );
        }

        $resourcePath = '/api/image/ImageDeletePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_delete_page_parameters)) {
            $_tempBody = $image_delete_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageDetectBlankPages
     *
     * Detects the blank page(s) from a previously uploaded image and offers to remove them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectBlankPagesParameters $image_detect_blank_pages_parameters An ImageDetectBlankPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageDetectBlankPagesResponse
     */
    public function imageDetectBlankPages($image_detect_blank_pages_parameters)
    {
        list($response) = $this->imageDetectBlankPagesWithHttpInfo($image_detect_blank_pages_parameters);
        return $response;
    }

    /**
     * Operation imageDetectBlankPagesWithHttpInfo
     *
     * Detects the blank page(s) from a previously uploaded image and offers to remove them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectBlankPagesParameters $image_detect_blank_pages_parameters An ImageDetectBlankPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageDetectBlankPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageDetectBlankPagesWithHttpInfo($image_detect_blank_pages_parameters)
    {
        $request = $this->imageDetectBlankPagesRequest($image_detect_blank_pages_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageDetectBlankPagesResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageDetectBlankPagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageDetectBlankPagesResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageDetectBlankPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageDetectBlankPagesAsync
     *
     * Detects the blank page(s) from a previously uploaded image and offers to remove them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectBlankPagesParameters $image_detect_blank_pages_parameters An ImageDetectBlankPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDetectBlankPagesAsync($image_detect_blank_pages_parameters)
    {
        return $this->imageDetectBlankPagesAsyncWithHttpInfo($image_detect_blank_pages_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageDetectBlankPagesAsyncWithHttpInfo
     *
     * Detects the blank page(s) from a previously uploaded image and offers to remove them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectBlankPagesParameters $image_detect_blank_pages_parameters An ImageDetectBlankPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDetectBlankPagesAsyncWithHttpInfo($image_detect_blank_pages_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageDetectBlankPagesResponse';
        $request = $this->imageDetectBlankPagesRequest($image_detect_blank_pages_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageDetectBlankPages'
     *
     * @param  \OpenAPI\Client\Model\ImageDetectBlankPagesParameters $image_detect_blank_pages_parameters An ImageDetectBlankPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageDetectBlankPagesRequest($image_detect_blank_pages_parameters)
    {
        // verify the required parameter 'image_detect_blank_pages_parameters' is set
        if ($image_detect_blank_pages_parameters === null || (is_array($image_detect_blank_pages_parameters) && count($image_detect_blank_pages_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_detect_blank_pages_parameters when calling imageDetectBlankPages'
            );
        }

        $resourcePath = '/api/image/ImageDetectBlankPages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_detect_blank_pages_parameters)) {
            $_tempBody = $image_detect_blank_pages_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageDetectColor
     *
     * Performs color detection  on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectColorParameters $image_detect_color_parameters An ImageDetectColorParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageDetectColorResponse
     */
    public function imageDetectColor($image_detect_color_parameters)
    {
        list($response) = $this->imageDetectColorWithHttpInfo($image_detect_color_parameters);
        return $response;
    }

    /**
     * Operation imageDetectColorWithHttpInfo
     *
     * Performs color detection  on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectColorParameters $image_detect_color_parameters An ImageDetectColorParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageDetectColorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageDetectColorWithHttpInfo($image_detect_color_parameters)
    {
        $request = $this->imageDetectColorRequest($image_detect_color_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageDetectColorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageDetectColorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageDetectColorResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageDetectColorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageDetectColorAsync
     *
     * Performs color detection  on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectColorParameters $image_detect_color_parameters An ImageDetectColorParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDetectColorAsync($image_detect_color_parameters)
    {
        return $this->imageDetectColorAsyncWithHttpInfo($image_detect_color_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageDetectColorAsyncWithHttpInfo
     *
     * Performs color detection  on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectColorParameters $image_detect_color_parameters An ImageDetectColorParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDetectColorAsyncWithHttpInfo($image_detect_color_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageDetectColorResponse';
        $request = $this->imageDetectColorRequest($image_detect_color_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageDetectColor'
     *
     * @param  \OpenAPI\Client\Model\ImageDetectColorParameters $image_detect_color_parameters An ImageDetectColorParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageDetectColorRequest($image_detect_color_parameters)
    {
        // verify the required parameter 'image_detect_color_parameters' is set
        if ($image_detect_color_parameters === null || (is_array($image_detect_color_parameters) && count($image_detect_color_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_detect_color_parameters when calling imageDetectColor'
            );
        }

        $resourcePath = '/api/image/ImageDetectColor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_detect_color_parameters)) {
            $_tempBody = $image_detect_color_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageDetectPageOrientation
     *
     * Detects the orientation of the page(s) of a previously uploaded image and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectPageOrientationParameters $image_detect_page_orientation_parameters An ImagedetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageDetectPageOrientationResponse
     */
    public function imageDetectPageOrientation($image_detect_page_orientation_parameters)
    {
        list($response) = $this->imageDetectPageOrientationWithHttpInfo($image_detect_page_orientation_parameters);
        return $response;
    }

    /**
     * Operation imageDetectPageOrientationWithHttpInfo
     *
     * Detects the orientation of the page(s) of a previously uploaded image and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectPageOrientationParameters $image_detect_page_orientation_parameters An ImagedetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageDetectPageOrientationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageDetectPageOrientationWithHttpInfo($image_detect_page_orientation_parameters)
    {
        $request = $this->imageDetectPageOrientationRequest($image_detect_page_orientation_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageDetectPageOrientationResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageDetectPageOrientationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageDetectPageOrientationResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageDetectPageOrientationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageDetectPageOrientationAsync
     *
     * Detects the orientation of the page(s) of a previously uploaded image and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectPageOrientationParameters $image_detect_page_orientation_parameters An ImagedetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDetectPageOrientationAsync($image_detect_page_orientation_parameters)
    {
        return $this->imageDetectPageOrientationAsyncWithHttpInfo($image_detect_page_orientation_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageDetectPageOrientationAsyncWithHttpInfo
     *
     * Detects the orientation of the page(s) of a previously uploaded image and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\ImageDetectPageOrientationParameters $image_detect_page_orientation_parameters An ImagedetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageDetectPageOrientationAsyncWithHttpInfo($image_detect_page_orientation_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageDetectPageOrientationResponse';
        $request = $this->imageDetectPageOrientationRequest($image_detect_page_orientation_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageDetectPageOrientation'
     *
     * @param  \OpenAPI\Client\Model\ImageDetectPageOrientationParameters $image_detect_page_orientation_parameters An ImagedetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageDetectPageOrientationRequest($image_detect_page_orientation_parameters)
    {
        // verify the required parameter 'image_detect_page_orientation_parameters' is set
        if ($image_detect_page_orientation_parameters === null || (is_array($image_detect_page_orientation_parameters) && count($image_detect_page_orientation_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_detect_page_orientation_parameters when calling imageDetectPageOrientation'
            );
        }

        $resourcePath = '/api/image/ImageDetectPageOrientation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_detect_page_orientation_parameters)) {
            $_tempBody = $image_detect_page_orientation_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageFilter
     *
     * Applies filters to a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageFilterParameters $image_filter_parameters An ImageFilterParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageFilterResponse
     */
    public function imageFilter($image_filter_parameters)
    {
        list($response) = $this->imageFilterWithHttpInfo($image_filter_parameters);
        return $response;
    }

    /**
     * Operation imageFilterWithHttpInfo
     *
     * Applies filters to a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageFilterParameters $image_filter_parameters An ImageFilterParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageFilterResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageFilterWithHttpInfo($image_filter_parameters)
    {
        $request = $this->imageFilterRequest($image_filter_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageFilterResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageFilterResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageFilterResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageFilterResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageFilterAsync
     *
     * Applies filters to a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageFilterParameters $image_filter_parameters An ImageFilterParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageFilterAsync($image_filter_parameters)
    {
        return $this->imageFilterAsyncWithHttpInfo($image_filter_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageFilterAsyncWithHttpInfo
     *
     * Applies filters to a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageFilterParameters $image_filter_parameters An ImageFilterParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageFilterAsyncWithHttpInfo($image_filter_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageFilterResponse';
        $request = $this->imageFilterRequest($image_filter_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageFilter'
     *
     * @param  \OpenAPI\Client\Model\ImageFilterParameters $image_filter_parameters An ImageFilterParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageFilterRequest($image_filter_parameters)
    {
        // verify the required parameter 'image_filter_parameters' is set
        if ($image_filter_parameters === null || (is_array($image_filter_parameters) && count($image_filter_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_filter_parameters when calling imageFilter'
            );
        }

        $resourcePath = '/api/image/ImageFilter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_filter_parameters)) {
            $_tempBody = $image_filter_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageGetPageThumbnail
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageGetPageThumbnailParameters $image_get_page_thumbnail_parameters A PDFGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageGetPageThumbnailResponse
     */
    public function imageGetPageThumbnail($image_get_page_thumbnail_parameters)
    {
        list($response) = $this->imageGetPageThumbnailWithHttpInfo($image_get_page_thumbnail_parameters);
        return $response;
    }

    /**
     * Operation imageGetPageThumbnailWithHttpInfo
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageGetPageThumbnailParameters $image_get_page_thumbnail_parameters A PDFGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageGetPageThumbnailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageGetPageThumbnailWithHttpInfo($image_get_page_thumbnail_parameters)
    {
        $request = $this->imageGetPageThumbnailRequest($image_get_page_thumbnail_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageGetPageThumbnailResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageGetPageThumbnailResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageGetPageThumbnailResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageGetPageThumbnailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageGetPageThumbnailAsync
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageGetPageThumbnailParameters $image_get_page_thumbnail_parameters A PDFGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageGetPageThumbnailAsync($image_get_page_thumbnail_parameters)
    {
        return $this->imageGetPageThumbnailAsyncWithHttpInfo($image_get_page_thumbnail_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageGetPageThumbnailAsyncWithHttpInfo
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageGetPageThumbnailParameters $image_get_page_thumbnail_parameters A PDFGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageGetPageThumbnailAsyncWithHttpInfo($image_get_page_thumbnail_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageGetPageThumbnailResponse';
        $request = $this->imageGetPageThumbnailRequest($image_get_page_thumbnail_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageGetPageThumbnail'
     *
     * @param  \OpenAPI\Client\Model\ImageGetPageThumbnailParameters $image_get_page_thumbnail_parameters A PDFGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageGetPageThumbnailRequest($image_get_page_thumbnail_parameters)
    {
        // verify the required parameter 'image_get_page_thumbnail_parameters' is set
        if ($image_get_page_thumbnail_parameters === null || (is_array($image_get_page_thumbnail_parameters) && count($image_get_page_thumbnail_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_get_page_thumbnail_parameters when calling imageGetPageThumbnail'
            );
        }

        $resourcePath = '/api/image/ImageGetPageThumbnail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_get_page_thumbnail_parameters)) {
            $_tempBody = $image_get_page_thumbnail_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageGetSupportedFileExtensions
     *
     * Gets the supported file extensions by the image loading actions.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringArrayResponse
     */
    public function imageGetSupportedFileExtensions()
    {
        list($response) = $this->imageGetSupportedFileExtensionsWithHttpInfo();
        return $response;
    }

    /**
     * Operation imageGetSupportedFileExtensionsWithHttpInfo
     *
     * Gets the supported file extensions by the image loading actions.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringArrayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageGetSupportedFileExtensionsWithHttpInfo()
    {
        $request = $this->imageGetSupportedFileExtensionsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StringArrayResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StringArrayResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\StringArrayResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringArrayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageGetSupportedFileExtensionsAsync
     *
     * Gets the supported file extensions by the image loading actions.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageGetSupportedFileExtensionsAsync()
    {
        return $this->imageGetSupportedFileExtensionsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageGetSupportedFileExtensionsAsyncWithHttpInfo
     *
     * Gets the supported file extensions by the image loading actions.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageGetSupportedFileExtensionsAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\StringArrayResponse';
        $request = $this->imageGetSupportedFileExtensionsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageGetSupportedFileExtensions'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageGetSupportedFileExtensionsRequest()
    {

        $resourcePath = '/api/image/ImageGetSupportedFileExtensions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageLoad
     *
     * Loads the provided image file.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\LoadImageFromByteArrayParameters $load_image_from_byte_array_parameters A LoadImageFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageLoadResponse
     */
    public function imageLoad($load_image_from_byte_array_parameters)
    {
        list($response) = $this->imageLoadWithHttpInfo($load_image_from_byte_array_parameters);
        return $response;
    }

    /**
     * Operation imageLoadWithHttpInfo
     *
     * Loads the provided image file.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\LoadImageFromByteArrayParameters $load_image_from_byte_array_parameters A LoadImageFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageLoadResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageLoadWithHttpInfo($load_image_from_byte_array_parameters)
    {
        $request = $this->imageLoadRequest($load_image_from_byte_array_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageLoadResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageLoadResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageLoadResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageLoadResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageLoadAsync
     *
     * Loads the provided image file.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\LoadImageFromByteArrayParameters $load_image_from_byte_array_parameters A LoadImageFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageLoadAsync($load_image_from_byte_array_parameters)
    {
        return $this->imageLoadAsyncWithHttpInfo($load_image_from_byte_array_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageLoadAsyncWithHttpInfo
     *
     * Loads the provided image file.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\LoadImageFromByteArrayParameters $load_image_from_byte_array_parameters A LoadImageFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageLoadAsyncWithHttpInfo($load_image_from_byte_array_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageLoadResponse';
        $request = $this->imageLoadRequest($load_image_from_byte_array_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageLoad'
     *
     * @param  \OpenAPI\Client\Model\LoadImageFromByteArrayParameters $load_image_from_byte_array_parameters A LoadImageFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageLoadRequest($load_image_from_byte_array_parameters)
    {
        // verify the required parameter 'load_image_from_byte_array_parameters' is set
        if ($load_image_from_byte_array_parameters === null || (is_array($load_image_from_byte_array_parameters) && count($load_image_from_byte_array_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $load_image_from_byte_array_parameters when calling imageLoad'
            );
        }

        $resourcePath = '/api/image/ImageLoad';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($load_image_from_byte_array_parameters)) {
            $_tempBody = $load_image_from_byte_array_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageLoadMultipart
     *
     * Loads the provided image file using Multipart Upload.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\LoadImageParameters $load_image_parameters load_image_parameters (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageLoadResponse
     */
    public function imageLoadMultipart($file_data, $load_image_parameters = null)
    {
        list($response) = $this->imageLoadMultipartWithHttpInfo($file_data, $load_image_parameters);
        return $response;
    }

    /**
     * Operation imageLoadMultipartWithHttpInfo
     *
     * Loads the provided image file using Multipart Upload.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\LoadImageParameters $load_image_parameters (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageLoadResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageLoadMultipartWithHttpInfo($file_data, $load_image_parameters = null)
    {
        $request = $this->imageLoadMultipartRequest($file_data, $load_image_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageLoadResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageLoadResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageLoadResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageLoadResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageLoadMultipartAsync
     *
     * Loads the provided image file using Multipart Upload.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\LoadImageParameters $load_image_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageLoadMultipartAsync($file_data, $load_image_parameters = null)
    {
        return $this->imageLoadMultipartAsyncWithHttpInfo($file_data, $load_image_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageLoadMultipartAsyncWithHttpInfo
     *
     * Loads the provided image file using Multipart Upload.  Supported image formats can be retrieved by the GetSupportedImageFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\LoadImageParameters $load_image_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageLoadMultipartAsyncWithHttpInfo($file_data, $load_image_parameters = null)
    {
        $returnType = '\OpenAPI\Client\Model\ImageLoadResponse';
        $request = $this->imageLoadMultipartRequest($file_data, $load_image_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageLoadMultipart'
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\LoadImageParameters $load_image_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageLoadMultipartRequest($file_data, $load_image_parameters = null)
    {
        // verify the required parameter 'file_data' is set
        if ($file_data === null || (is_array($file_data) && count($file_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_data when calling imageLoadMultipart'
            );
        }

        $resourcePath = '/api/image/ImageLoadMultipart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($file_data !== null) {
            $multipart = true;
            $formParams['fileData'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file_data), 'rb');
        }
        // form params
        if ($load_image_parameters !== null) {
            $formParams['loadImageParameters'] = ObjectSerializer::toFormValue($load_image_parameters);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageMICR
     *
     * Performs MICR (Magnetic Ink Character Recognition) on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageMICRParameters $image_micr_parameters An ImageMICRParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageMICRResponse
     */
    public function imageMICR($image_micr_parameters)
    {
        list($response) = $this->imageMICRWithHttpInfo($image_micr_parameters);
        return $response;
    }

    /**
     * Operation imageMICRWithHttpInfo
     *
     * Performs MICR (Magnetic Ink Character Recognition) on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageMICRParameters $image_micr_parameters An ImageMICRParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageMICRResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageMICRWithHttpInfo($image_micr_parameters)
    {
        $request = $this->imageMICRRequest($image_micr_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageMICRResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageMICRResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageMICRResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageMICRResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageMICRAsync
     *
     * Performs MICR (Magnetic Ink Character Recognition) on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageMICRParameters $image_micr_parameters An ImageMICRParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageMICRAsync($image_micr_parameters)
    {
        return $this->imageMICRAsyncWithHttpInfo($image_micr_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageMICRAsyncWithHttpInfo
     *
     * Performs MICR (Magnetic Ink Character Recognition) on a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageMICRParameters $image_micr_parameters An ImageMICRParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageMICRAsyncWithHttpInfo($image_micr_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageMICRResponse';
        $request = $this->imageMICRRequest($image_micr_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageMICR'
     *
     * @param  \OpenAPI\Client\Model\ImageMICRParameters $image_micr_parameters An ImageMICRParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageMICRRequest($image_micr_parameters)
    {
        // verify the required parameter 'image_micr_parameters' is set
        if ($image_micr_parameters === null || (is_array($image_micr_parameters) && count($image_micr_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_micr_parameters when calling imageMICR'
            );
        }

        $resourcePath = '/api/image/ImageMICR';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_micr_parameters)) {
            $_tempBody = $image_micr_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageReadBarcodes
     *
     * Reads barcodes from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageReadBarcodesParameters $image_read_barcodes_parameters An ImageReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ReadBarcodesResponse
     */
    public function imageReadBarcodes($image_read_barcodes_parameters)
    {
        list($response) = $this->imageReadBarcodesWithHttpInfo($image_read_barcodes_parameters);
        return $response;
    }

    /**
     * Operation imageReadBarcodesWithHttpInfo
     *
     * Reads barcodes from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageReadBarcodesParameters $image_read_barcodes_parameters An ImageReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ReadBarcodesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageReadBarcodesWithHttpInfo($image_read_barcodes_parameters)
    {
        $request = $this->imageReadBarcodesRequest($image_read_barcodes_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ReadBarcodesResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ReadBarcodesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ReadBarcodesResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ReadBarcodesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageReadBarcodesAsync
     *
     * Reads barcodes from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageReadBarcodesParameters $image_read_barcodes_parameters An ImageReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageReadBarcodesAsync($image_read_barcodes_parameters)
    {
        return $this->imageReadBarcodesAsyncWithHttpInfo($image_read_barcodes_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageReadBarcodesAsyncWithHttpInfo
     *
     * Reads barcodes from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageReadBarcodesParameters $image_read_barcodes_parameters An ImageReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageReadBarcodesAsyncWithHttpInfo($image_read_barcodes_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ReadBarcodesResponse';
        $request = $this->imageReadBarcodesRequest($image_read_barcodes_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageReadBarcodes'
     *
     * @param  \OpenAPI\Client\Model\ImageReadBarcodesParameters $image_read_barcodes_parameters An ImageReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageReadBarcodesRequest($image_read_barcodes_parameters)
    {
        // verify the required parameter 'image_read_barcodes_parameters' is set
        if ($image_read_barcodes_parameters === null || (is_array($image_read_barcodes_parameters) && count($image_read_barcodes_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_read_barcodes_parameters when calling imageReadBarcodes'
            );
        }

        $resourcePath = '/api/image/ImageReadBarcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_read_barcodes_parameters)) {
            $_tempBody = $image_read_barcodes_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageResize
     *
     * Resizes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageResizeParameters $image_resize_parameters An ImageResizeParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageResizeResponse
     */
    public function imageResize($image_resize_parameters)
    {
        list($response) = $this->imageResizeWithHttpInfo($image_resize_parameters);
        return $response;
    }

    /**
     * Operation imageResizeWithHttpInfo
     *
     * Resizes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageResizeParameters $image_resize_parameters An ImageResizeParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageResizeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageResizeWithHttpInfo($image_resize_parameters)
    {
        $request = $this->imageResizeRequest($image_resize_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageResizeResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageResizeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageResizeResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageResizeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageResizeAsync
     *
     * Resizes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageResizeParameters $image_resize_parameters An ImageResizeParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageResizeAsync($image_resize_parameters)
    {
        return $this->imageResizeAsyncWithHttpInfo($image_resize_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageResizeAsyncWithHttpInfo
     *
     * Resizes a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageResizeParameters $image_resize_parameters An ImageResizeParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageResizeAsyncWithHttpInfo($image_resize_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageResizeResponse';
        $request = $this->imageResizeRequest($image_resize_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageResize'
     *
     * @param  \OpenAPI\Client\Model\ImageResizeParameters $image_resize_parameters An ImageResizeParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageResizeRequest($image_resize_parameters)
    {
        // verify the required parameter 'image_resize_parameters' is set
        if ($image_resize_parameters === null || (is_array($image_resize_parameters) && count($image_resize_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_resize_parameters when calling imageResize'
            );
        }

        $resourcePath = '/api/image/ImageResize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_resize_parameters)) {
            $_tempBody = $image_resize_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageRotate
     *
     * Rotates and/or flips a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageRotateParameters $image_rotate_parameters An ImageRotateParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageRotateResponse
     */
    public function imageRotate($image_rotate_parameters)
    {
        list($response) = $this->imageRotateWithHttpInfo($image_rotate_parameters);
        return $response;
    }

    /**
     * Operation imageRotateWithHttpInfo
     *
     * Rotates and/or flips a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageRotateParameters $image_rotate_parameters An ImageRotateParameters object specifying the parameters for the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageRotateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageRotateWithHttpInfo($image_rotate_parameters)
    {
        $request = $this->imageRotateRequest($image_rotate_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageRotateResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageRotateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageRotateResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageRotateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageRotateAsync
     *
     * Rotates and/or flips a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageRotateParameters $image_rotate_parameters An ImageRotateParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageRotateAsync($image_rotate_parameters)
    {
        return $this->imageRotateAsyncWithHttpInfo($image_rotate_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageRotateAsyncWithHttpInfo
     *
     * Rotates and/or flips a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageRotateParameters $image_rotate_parameters An ImageRotateParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageRotateAsyncWithHttpInfo($image_rotate_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageRotateResponse';
        $request = $this->imageRotateRequest($image_rotate_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageRotate'
     *
     * @param  \OpenAPI\Client\Model\ImageRotateParameters $image_rotate_parameters An ImageRotateParameters object specifying the parameters for the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageRotateRequest($image_rotate_parameters)
    {
        // verify the required parameter 'image_rotate_parameters' is set
        if ($image_rotate_parameters === null || (is_array($image_rotate_parameters) && count($image_rotate_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_rotate_parameters when calling imageRotate'
            );
        }

        $resourcePath = '/api/image/ImageRotate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_rotate_parameters)) {
            $_tempBody = $image_rotate_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsJPEG
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageSaveAsJPEGResponse
     */
    public function imageSaveAsJPEG($image_save_as_jpeg_parameters)
    {
        list($response) = $this->imageSaveAsJPEGWithHttpInfo($image_save_as_jpeg_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsJPEGWithHttpInfo
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageSaveAsJPEGResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsJPEGWithHttpInfo($image_save_as_jpeg_parameters)
    {
        $request = $this->imageSaveAsJPEGRequest($image_save_as_jpeg_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageSaveAsJPEGResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageSaveAsJPEGResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageSaveAsJPEGResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageSaveAsJPEGResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsJPEGAsync
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsJPEGAsync($image_save_as_jpeg_parameters)
    {
        return $this->imageSaveAsJPEGAsyncWithHttpInfo($image_save_as_jpeg_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsJPEGAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsJPEGAsyncWithHttpInfo($image_save_as_jpeg_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageSaveAsJPEGResponse';
        $request = $this->imageSaveAsJPEGRequest($image_save_as_jpeg_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsJPEG'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsJPEGRequest($image_save_as_jpeg_parameters)
    {
        // verify the required parameter 'image_save_as_jpeg_parameters' is set
        if ($image_save_as_jpeg_parameters === null || (is_array($image_save_as_jpeg_parameters) && count($image_save_as_jpeg_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_jpeg_parameters when calling imageSaveAsJPEG'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsJPEG';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_jpeg_parameters)) {
            $_tempBody = $image_save_as_jpeg_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsJPEGFile
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function imageSaveAsJPEGFile($image_save_as_jpeg_parameters)
    {
        list($response) = $this->imageSaveAsJPEGFileWithHttpInfo($image_save_as_jpeg_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsJPEGFileWithHttpInfo
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsJPEGFileWithHttpInfo($image_save_as_jpeg_parameters)
    {
        $request = $this->imageSaveAsJPEGFileRequest($image_save_as_jpeg_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsJPEGFileAsync
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsJPEGFileAsync($image_save_as_jpeg_parameters)
    {
        return $this->imageSaveAsJPEGFileAsyncWithHttpInfo($image_save_as_jpeg_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsJPEGFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as JPEG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsJPEGFileAsyncWithHttpInfo($image_save_as_jpeg_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->imageSaveAsJPEGFileRequest($image_save_as_jpeg_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsJPEGFile'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsJPEGParameters $image_save_as_jpeg_parameters An ImageSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsJPEGFileRequest($image_save_as_jpeg_parameters)
    {
        // verify the required parameter 'image_save_as_jpeg_parameters' is set
        if ($image_save_as_jpeg_parameters === null || (is_array($image_save_as_jpeg_parameters) && count($image_save_as_jpeg_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_jpeg_parameters when calling imageSaveAsJPEGFile'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsJPEGFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_jpeg_parameters)) {
            $_tempBody = $image_save_as_jpeg_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsPDF
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageSaveAsPDFResponse
     */
    public function imageSaveAsPDF($image_save_as_pdf_parameters)
    {
        list($response) = $this->imageSaveAsPDFWithHttpInfo($image_save_as_pdf_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsPDFWithHttpInfo
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageSaveAsPDFResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsPDFWithHttpInfo($image_save_as_pdf_parameters)
    {
        $request = $this->imageSaveAsPDFRequest($image_save_as_pdf_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageSaveAsPDFResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageSaveAsPDFResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageSaveAsPDFResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageSaveAsPDFResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsPDFAsync
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFAsync($image_save_as_pdf_parameters)
    {
        return $this->imageSaveAsPDFAsyncWithHttpInfo($image_save_as_pdf_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsPDFAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFAsyncWithHttpInfo($image_save_as_pdf_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageSaveAsPDFResponse';
        $request = $this->imageSaveAsPDFRequest($image_save_as_pdf_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsPDF'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsPDFRequest($image_save_as_pdf_parameters)
    {
        // verify the required parameter 'image_save_as_pdf_parameters' is set
        if ($image_save_as_pdf_parameters === null || (is_array($image_save_as_pdf_parameters) && count($image_save_as_pdf_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_pdf_parameters when calling imageSaveAsPDF'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsPDF';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_pdf_parameters)) {
            $_tempBody = $image_save_as_pdf_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsPDFFile
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function imageSaveAsPDFFile($image_save_as_pdf_parameters)
    {
        list($response) = $this->imageSaveAsPDFFileWithHttpInfo($image_save_as_pdf_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsPDFFileWithHttpInfo
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsPDFFileWithHttpInfo($image_save_as_pdf_parameters)
    {
        $request = $this->imageSaveAsPDFFileRequest($image_save_as_pdf_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsPDFFileAsync
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFFileAsync($image_save_as_pdf_parameters)
    {
        return $this->imageSaveAsPDFFileAsyncWithHttpInfo($image_save_as_pdf_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsPDFFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as PDF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFFileAsyncWithHttpInfo($image_save_as_pdf_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->imageSaveAsPDFFileRequest($image_save_as_pdf_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsPDFFile'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFParameters $image_save_as_pdf_parameters An ImagesaveAsPDFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsPDFFileRequest($image_save_as_pdf_parameters)
    {
        // verify the required parameter 'image_save_as_pdf_parameters' is set
        if ($image_save_as_pdf_parameters === null || (is_array($image_save_as_pdf_parameters) && count($image_save_as_pdf_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_pdf_parameters when calling imageSaveAsPDFFile'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsPDFFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_pdf_parameters)) {
            $_tempBody = $image_save_as_pdf_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsPDFMRC
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageSaveAsPDFMRCResponse
     */
    public function imageSaveAsPDFMRC($image_save_as_pdfmrc_parameters)
    {
        list($response) = $this->imageSaveAsPDFMRCWithHttpInfo($image_save_as_pdfmrc_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsPDFMRCWithHttpInfo
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageSaveAsPDFMRCResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsPDFMRCWithHttpInfo($image_save_as_pdfmrc_parameters)
    {
        $request = $this->imageSaveAsPDFMRCRequest($image_save_as_pdfmrc_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageSaveAsPDFMRCResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageSaveAsPDFMRCResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageSaveAsPDFMRCResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageSaveAsPDFMRCResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsPDFMRCAsync
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFMRCAsync($image_save_as_pdfmrc_parameters)
    {
        return $this->imageSaveAsPDFMRCAsyncWithHttpInfo($image_save_as_pdfmrc_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsPDFMRCAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFMRCAsyncWithHttpInfo($image_save_as_pdfmrc_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageSaveAsPDFMRCResponse';
        $request = $this->imageSaveAsPDFMRCRequest($image_save_as_pdfmrc_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsPDFMRC'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsPDFMRCRequest($image_save_as_pdfmrc_parameters)
    {
        // verify the required parameter 'image_save_as_pdfmrc_parameters' is set
        if ($image_save_as_pdfmrc_parameters === null || (is_array($image_save_as_pdfmrc_parameters) && count($image_save_as_pdfmrc_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_pdfmrc_parameters when calling imageSaveAsPDFMRC'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsPDFMRC';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_pdfmrc_parameters)) {
            $_tempBody = $image_save_as_pdfmrc_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsPDFMRCFile
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function imageSaveAsPDFMRCFile($image_save_as_pdfmrc_parameters)
    {
        list($response) = $this->imageSaveAsPDFMRCFileWithHttpInfo($image_save_as_pdfmrc_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsPDFMRCFileWithHttpInfo
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsPDFMRCFileWithHttpInfo($image_save_as_pdfmrc_parameters)
    {
        $request = $this->imageSaveAsPDFMRCFileRequest($image_save_as_pdfmrc_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsPDFMRCFileAsync
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFMRCFileAsync($image_save_as_pdfmrc_parameters)
    {
        return $this->imageSaveAsPDFMRCFileAsyncWithHttpInfo($image_save_as_pdfmrc_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsPDFMRCFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as PDF using MRC compression.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPDFMRCFileAsyncWithHttpInfo($image_save_as_pdfmrc_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->imageSaveAsPDFMRCFileRequest($image_save_as_pdfmrc_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsPDFMRCFile'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPDFMRCParameters $image_save_as_pdfmrc_parameters An ImagesaveAsPDFMRCParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsPDFMRCFileRequest($image_save_as_pdfmrc_parameters)
    {
        // verify the required parameter 'image_save_as_pdfmrc_parameters' is set
        if ($image_save_as_pdfmrc_parameters === null || (is_array($image_save_as_pdfmrc_parameters) && count($image_save_as_pdfmrc_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_pdfmrc_parameters when calling imageSaveAsPDFMRCFile'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsPDFMRCFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_pdfmrc_parameters)) {
            $_tempBody = $image_save_as_pdfmrc_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsPNG
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageSaveAsPNGResponse
     */
    public function imageSaveAsPNG($image_save_as_png_parameters)
    {
        list($response) = $this->imageSaveAsPNGWithHttpInfo($image_save_as_png_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsPNGWithHttpInfo
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageSaveAsPNGResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsPNGWithHttpInfo($image_save_as_png_parameters)
    {
        $request = $this->imageSaveAsPNGRequest($image_save_as_png_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageSaveAsPNGResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageSaveAsPNGResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageSaveAsPNGResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageSaveAsPNGResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsPNGAsync
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPNGAsync($image_save_as_png_parameters)
    {
        return $this->imageSaveAsPNGAsyncWithHttpInfo($image_save_as_png_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsPNGAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPNGAsyncWithHttpInfo($image_save_as_png_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageSaveAsPNGResponse';
        $request = $this->imageSaveAsPNGRequest($image_save_as_png_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsPNG'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsPNGRequest($image_save_as_png_parameters)
    {
        // verify the required parameter 'image_save_as_png_parameters' is set
        if ($image_save_as_png_parameters === null || (is_array($image_save_as_png_parameters) && count($image_save_as_png_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_png_parameters when calling imageSaveAsPNG'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsPNG';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_png_parameters)) {
            $_tempBody = $image_save_as_png_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsPNGFile
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function imageSaveAsPNGFile($image_save_as_png_parameters)
    {
        list($response) = $this->imageSaveAsPNGFileWithHttpInfo($image_save_as_png_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsPNGFileWithHttpInfo
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsPNGFileWithHttpInfo($image_save_as_png_parameters)
    {
        $request = $this->imageSaveAsPNGFileRequest($image_save_as_png_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsPNGFileAsync
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPNGFileAsync($image_save_as_png_parameters)
    {
        return $this->imageSaveAsPNGFileAsyncWithHttpInfo($image_save_as_png_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsPNGFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as PNG.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsPNGFileAsyncWithHttpInfo($image_save_as_png_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->imageSaveAsPNGFileRequest($image_save_as_png_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsPNGFile'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsPNGParameters $image_save_as_png_parameters An ImageSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsPNGFileRequest($image_save_as_png_parameters)
    {
        // verify the required parameter 'image_save_as_png_parameters' is set
        if ($image_save_as_png_parameters === null || (is_array($image_save_as_png_parameters) && count($image_save_as_png_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_png_parameters when calling imageSaveAsPNGFile'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsPNGFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_png_parameters)) {
            $_tempBody = $image_save_as_png_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsTIFF
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageSaveAsTIFFResponse
     */
    public function imageSaveAsTIFF($image_save_as_tiff_parameters)
    {
        list($response) = $this->imageSaveAsTIFFWithHttpInfo($image_save_as_tiff_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsTIFFWithHttpInfo
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageSaveAsTIFFResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsTIFFWithHttpInfo($image_save_as_tiff_parameters)
    {
        $request = $this->imageSaveAsTIFFRequest($image_save_as_tiff_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageSaveAsTIFFResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageSaveAsTIFFResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageSaveAsTIFFResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageSaveAsTIFFResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsTIFFAsync
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFAsync($image_save_as_tiff_parameters)
    {
        return $this->imageSaveAsTIFFAsyncWithHttpInfo($image_save_as_tiff_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsTIFFAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFAsyncWithHttpInfo($image_save_as_tiff_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageSaveAsTIFFResponse';
        $request = $this->imageSaveAsTIFFRequest($image_save_as_tiff_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsTIFF'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsTIFFRequest($image_save_as_tiff_parameters)
    {
        // verify the required parameter 'image_save_as_tiff_parameters' is set
        if ($image_save_as_tiff_parameters === null || (is_array($image_save_as_tiff_parameters) && count($image_save_as_tiff_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_tiff_parameters when calling imageSaveAsTIFF'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsTIFF';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_tiff_parameters)) {
            $_tempBody = $image_save_as_tiff_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsTIFFFile
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function imageSaveAsTIFFFile($image_save_as_tiff_parameters)
    {
        list($response) = $this->imageSaveAsTIFFFileWithHttpInfo($image_save_as_tiff_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsTIFFFileWithHttpInfo
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsTIFFFileWithHttpInfo($image_save_as_tiff_parameters)
    {
        $request = $this->imageSaveAsTIFFFileRequest($image_save_as_tiff_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsTIFFFileAsync
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFFileAsync($image_save_as_tiff_parameters)
    {
        return $this->imageSaveAsTIFFFileAsyncWithHttpInfo($image_save_as_tiff_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsTIFFFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFFileAsyncWithHttpInfo($image_save_as_tiff_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->imageSaveAsTIFFFileRequest($image_save_as_tiff_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsTIFFFile'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFParameters $image_save_as_tiff_parameters An ImageSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsTIFFFileRequest($image_save_as_tiff_parameters)
    {
        // verify the required parameter 'image_save_as_tiff_parameters' is set
        if ($image_save_as_tiff_parameters === null || (is_array($image_save_as_tiff_parameters) && count($image_save_as_tiff_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_tiff_parameters when calling imageSaveAsTIFFFile'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsTIFFFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_tiff_parameters)) {
            $_tempBody = $image_save_as_tiff_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsTIFFMultipage
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageResponse
     */
    public function imageSaveAsTIFFMultipage($image_save_as_tiff_multipage_parameters)
    {
        list($response) = $this->imageSaveAsTIFFMultipageWithHttpInfo($image_save_as_tiff_multipage_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsTIFFMultipageWithHttpInfo
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsTIFFMultipageWithHttpInfo($image_save_as_tiff_multipage_parameters)
    {
        $request = $this->imageSaveAsTIFFMultipageRequest($image_save_as_tiff_multipage_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageSaveAsTIFFMultipageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageSaveAsTIFFMultipageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageSaveAsTIFFMultipageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageSaveAsTIFFMultipageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsTIFFMultipageAsync
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFMultipageAsync($image_save_as_tiff_multipage_parameters)
    {
        return $this->imageSaveAsTIFFMultipageAsyncWithHttpInfo($image_save_as_tiff_multipage_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsTIFFMultipageAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFMultipageAsyncWithHttpInfo($image_save_as_tiff_multipage_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageSaveAsTIFFMultipageResponse';
        $request = $this->imageSaveAsTIFFMultipageRequest($image_save_as_tiff_multipage_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsTIFFMultipage'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsTIFFMultipageRequest($image_save_as_tiff_multipage_parameters)
    {
        // verify the required parameter 'image_save_as_tiff_multipage_parameters' is set
        if ($image_save_as_tiff_multipage_parameters === null || (is_array($image_save_as_tiff_multipage_parameters) && count($image_save_as_tiff_multipage_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_tiff_multipage_parameters when calling imageSaveAsTIFFMultipage'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsTIFFMultipage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_tiff_multipage_parameters)) {
            $_tempBody = $image_save_as_tiff_multipage_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSaveAsTIFFMultipageFile
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function imageSaveAsTIFFMultipageFile($image_save_as_tiff_multipage_parameters)
    {
        list($response) = $this->imageSaveAsTIFFMultipageFileWithHttpInfo($image_save_as_tiff_multipage_parameters);
        return $response;
    }

    /**
     * Operation imageSaveAsTIFFMultipageFileWithHttpInfo
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSaveAsTIFFMultipageFileWithHttpInfo($image_save_as_tiff_multipage_parameters)
    {
        $request = $this->imageSaveAsTIFFMultipageFileRequest($image_save_as_tiff_multipage_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSaveAsTIFFMultipageFileAsync
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFMultipageFileAsync($image_save_as_tiff_multipage_parameters)
    {
        return $this->imageSaveAsTIFFMultipageFileAsyncWithHttpInfo($image_save_as_tiff_multipage_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSaveAsTIFFMultipageFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded image as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSaveAsTIFFMultipageFileAsyncWithHttpInfo($image_save_as_tiff_multipage_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->imageSaveAsTIFFMultipageFileRequest($image_save_as_tiff_multipage_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSaveAsTIFFMultipageFile'
     *
     * @param  \OpenAPI\Client\Model\ImageSaveAsTIFFMultipageParameters $image_save_as_tiff_multipage_parameters An ImageSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSaveAsTIFFMultipageFileRequest($image_save_as_tiff_multipage_parameters)
    {
        // verify the required parameter 'image_save_as_tiff_multipage_parameters' is set
        if ($image_save_as_tiff_multipage_parameters === null || (is_array($image_save_as_tiff_multipage_parameters) && count($image_save_as_tiff_multipage_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_save_as_tiff_multipage_parameters when calling imageSaveAsTIFFMultipageFile'
            );
        }

        $resourcePath = '/api/image/ImageSaveAsTIFFMultipageFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_save_as_tiff_multipage_parameters)) {
            $_tempBody = $image_save_as_tiff_multipage_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageSwapPages
     *
     * Swaps two pages from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageSwapPagesParameters $image_swap_pages_parameters An ImageSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageSwapPagesResponse
     */
    public function imageSwapPages($image_swap_pages_parameters)
    {
        list($response) = $this->imageSwapPagesWithHttpInfo($image_swap_pages_parameters);
        return $response;
    }

    /**
     * Operation imageSwapPagesWithHttpInfo
     *
     * Swaps two pages from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageSwapPagesParameters $image_swap_pages_parameters An ImageSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageSwapPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageSwapPagesWithHttpInfo($image_swap_pages_parameters)
    {
        $request = $this->imageSwapPagesRequest($image_swap_pages_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageSwapPagesResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageSwapPagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageSwapPagesResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageSwapPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageSwapPagesAsync
     *
     * Swaps two pages from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageSwapPagesParameters $image_swap_pages_parameters An ImageSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSwapPagesAsync($image_swap_pages_parameters)
    {
        return $this->imageSwapPagesAsyncWithHttpInfo($image_swap_pages_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageSwapPagesAsyncWithHttpInfo
     *
     * Swaps two pages from a previously uploaded image.
     *
     * @param  \OpenAPI\Client\Model\ImageSwapPagesParameters $image_swap_pages_parameters An ImageSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageSwapPagesAsyncWithHttpInfo($image_swap_pages_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ImageSwapPagesResponse';
        $request = $this->imageSwapPagesRequest($image_swap_pages_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageSwapPages'
     *
     * @param  \OpenAPI\Client\Model\ImageSwapPagesParameters $image_swap_pages_parameters An ImageSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageSwapPagesRequest($image_swap_pages_parameters)
    {
        // verify the required parameter 'image_swap_pages_parameters' is set
        if ($image_swap_pages_parameters === null || (is_array($image_swap_pages_parameters) && count($image_swap_pages_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_swap_pages_parameters when calling imageSwapPages'
            );
        }

        $resourcePath = '/api/image/ImageSwapPages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($image_swap_pages_parameters)) {
            $_tempBody = $image_swap_pages_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

<?php
/**
 * PDFApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PassportPDF API
 *
 * Introduction:    PassportPDF API is a REST API that lets you perform complex operations on documents and images easily.  You may consume the API by using our.NET SDK (other platforms / languages are soon to come), or any REST client by sending your requests to the appropriate endpoints.   A list of all the available endpoints can be found on the API reference page at https://passportpdfapi.com/references/api/index.html        Authentication:    Each available operation has a predefined cost, expressed as a number of tokens.  These tokens are deducted from your \"passport,\" which has a unique identifier that acts as an API key. This key is, therefore, required to be provided with each request for the latter to be honored(except if the operation does not have a cost, typically when you request a simple data with a GET).  Your key must be included in the header of the request, under the name \"X-PassportPdf-API-Key.\"  If you are using the.NET SDK, you can either set your key in the ApiKey property of your API instance(PdfApi or ImageApi, for example) or set it globally in the GlobalConfiguration instance if you want to set it once for the whole life cycle of your application.          Communication with the API:    All the available actions are listed on the API reference page, as previously mentioned.  There are several different controllers, i.e., routes, which categorize the actions.For example, you may use the PDF controller(\"/api/pdf\" route) to perform PDF - related operations, and the Image controller(\"/api/image\") for images.  Each action defines what kind of parameters(if any) is expected, and what kind of response is served.Parameters and responses are represented using data models, or \"schemas,\" and are listed in the \"Schemas\" section of the reference.   Parameters and response models of a given action are both prefixed by the controller name, the action name, and \"Parameters\" / \"Response,\" e.g. \"api/pdf/reduce\" respectively receives and serves a PdfReduceParameters and PdfReduceResponse models.  Using the .NET SDK, you will find the objects to interact with the different controllers in the PassportPDF.Api namespace and all the schemas in the PassportPDF.Model namespace.        Processing documents:    Each document manipulation starts with importing the file onto the API.  The LoadDocument action of the PDF controller lets you import your document as a PDF.  Note that the GetPDFImportSupportedFileExtensions action of the same controller will let you know all the different types of files that you may import as a PDF. LoadDocument responds with a JSON-serialized PdfLoadDocumentResponse model, which contains a \"FileId\" property.This identifier is required for the API to know about your document for further manipulations, hence the presence of a \"FileId\" property in the PdfReduceParameters schema (and many other parameters schemas). To download the changes made to a file, you need, of course, to download the new version of the file from the API.  To save your document as a PDF, you will need to use the SaveDocument action of the PDF controller and provide a PdfSaveDocumentParameters data model that contains the identifier of your file.        Errors:    Conventional HTTP response codes are used to indicate the success or failure of an API request.   The Error data model also defines some information about an error that occurred on the API.   Each response model has an Error in its definition, and its sole existence in the serialized response - which should thus always be checked - indicates that something went wrong.  Among the information given by the Error schema, \"ResultCode\" specifies a value of the \"PassportPDFStatus\" enumeration, that defines a first level of error information. \"InternalErrorId\" defines a unique identifier for the error, which comes very handy for us to troubleshoot any issue you may encounter quickly.        Efficiency considerations:    Multipart upload/download is available and lets you directly stream a file to/from the API.  In the PDF controller, LoadDocument/LoadDocumentMultipart and SaveDocument/SaveDocumentToFile may be used to upload/download a document using respectively binary data serialization and streaming multipart HTTP requests.  The second approach should be favored when dealing with large files, as it will be much more efficient in that context.
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * PDFApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PDFApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation annotate
     *
     * Annotates a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAnnotateParameters $pdf_annotate_parameters A PdfAnnotateParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfAnnotateResponse
     */
    public function annotate($pdf_annotate_parameters)
    {
        list($response) = $this->annotateWithHttpInfo($pdf_annotate_parameters);
        return $response;
    }

    /**
     * Operation annotateWithHttpInfo
     *
     * Annotates a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAnnotateParameters $pdf_annotate_parameters A PdfAnnotateParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfAnnotateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function annotateWithHttpInfo($pdf_annotate_parameters)
    {
        $request = $this->annotateRequest($pdf_annotate_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfAnnotateResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfAnnotateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfAnnotateResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfAnnotateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation annotateAsync
     *
     * Annotates a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAnnotateParameters $pdf_annotate_parameters A PdfAnnotateParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function annotateAsync($pdf_annotate_parameters)
    {
        return $this->annotateAsyncWithHttpInfo($pdf_annotate_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation annotateAsyncWithHttpInfo
     *
     * Annotates a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAnnotateParameters $pdf_annotate_parameters A PdfAnnotateParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function annotateAsyncWithHttpInfo($pdf_annotate_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfAnnotateResponse';
        $request = $this->annotateRequest($pdf_annotate_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'annotate'
     *
     * @param  \OpenAPI\Client\Model\PdfAnnotateParameters $pdf_annotate_parameters A PdfAnnotateParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function annotateRequest($pdf_annotate_parameters)
    {
        // verify the required parameter 'pdf_annotate_parameters' is set
        if ($pdf_annotate_parameters === null || (is_array($pdf_annotate_parameters) && count($pdf_annotate_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_annotate_parameters when calling annotate'
            );
        }

        $resourcePath = '/api/pdf/Annotate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_annotate_parameters)) {
            $_tempBody = $pdf_annotate_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autoDeskew
     *
     * Performs auto deskew on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAutoDeskewParameters $pdf_auto_deskew_parameters A PdfAutoDeskewParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfAutoDeskewResponse
     */
    public function autoDeskew($pdf_auto_deskew_parameters)
    {
        list($response) = $this->autoDeskewWithHttpInfo($pdf_auto_deskew_parameters);
        return $response;
    }

    /**
     * Operation autoDeskewWithHttpInfo
     *
     * Performs auto deskew on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAutoDeskewParameters $pdf_auto_deskew_parameters A PdfAutoDeskewParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfAutoDeskewResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function autoDeskewWithHttpInfo($pdf_auto_deskew_parameters)
    {
        $request = $this->autoDeskewRequest($pdf_auto_deskew_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfAutoDeskewResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfAutoDeskewResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfAutoDeskewResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfAutoDeskewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autoDeskewAsync
     *
     * Performs auto deskew on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAutoDeskewParameters $pdf_auto_deskew_parameters A PdfAutoDeskewParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autoDeskewAsync($pdf_auto_deskew_parameters)
    {
        return $this->autoDeskewAsyncWithHttpInfo($pdf_auto_deskew_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autoDeskewAsyncWithHttpInfo
     *
     * Performs auto deskew on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfAutoDeskewParameters $pdf_auto_deskew_parameters A PdfAutoDeskewParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autoDeskewAsyncWithHttpInfo($pdf_auto_deskew_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfAutoDeskewResponse';
        $request = $this->autoDeskewRequest($pdf_auto_deskew_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autoDeskew'
     *
     * @param  \OpenAPI\Client\Model\PdfAutoDeskewParameters $pdf_auto_deskew_parameters A PdfAutoDeskewParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autoDeskewRequest($pdf_auto_deskew_parameters)
    {
        // verify the required parameter 'pdf_auto_deskew_parameters' is set
        if ($pdf_auto_deskew_parameters === null || (is_array($pdf_auto_deskew_parameters) && count($pdf_auto_deskew_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_auto_deskew_parameters when calling autoDeskew'
            );
        }

        $resourcePath = '/api/pdf/AutoDeskew';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_auto_deskew_parameters)) {
            $_tempBody = $pdf_auto_deskew_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearPage
     *
     * Clears a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClearPageParameters $pdf_clear_page_parameters A PdfClearPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfClearPageResponse
     */
    public function clearPage($pdf_clear_page_parameters)
    {
        list($response) = $this->clearPageWithHttpInfo($pdf_clear_page_parameters);
        return $response;
    }

    /**
     * Operation clearPageWithHttpInfo
     *
     * Clears a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClearPageParameters $pdf_clear_page_parameters A PdfClearPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfClearPageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearPageWithHttpInfo($pdf_clear_page_parameters)
    {
        $request = $this->clearPageRequest($pdf_clear_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfClearPageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfClearPageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfClearPageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfClearPageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clearPageAsync
     *
     * Clears a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClearPageParameters $pdf_clear_page_parameters A PdfClearPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearPageAsync($pdf_clear_page_parameters)
    {
        return $this->clearPageAsyncWithHttpInfo($pdf_clear_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearPageAsyncWithHttpInfo
     *
     * Clears a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClearPageParameters $pdf_clear_page_parameters A PdfClearPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearPageAsyncWithHttpInfo($pdf_clear_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfClearPageResponse';
        $request = $this->clearPageRequest($pdf_clear_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearPage'
     *
     * @param  \OpenAPI\Client\Model\PdfClearPageParameters $pdf_clear_page_parameters A PdfClearPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clearPageRequest($pdf_clear_page_parameters)
    {
        // verify the required parameter 'pdf_clear_page_parameters' is set
        if ($pdf_clear_page_parameters === null || (is_array($pdf_clear_page_parameters) && count($pdf_clear_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_clear_page_parameters when calling clearPage'
            );
        }

        $resourcePath = '/api/pdf/ClearPage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_clear_page_parameters)) {
            $_tempBody = $pdf_clear_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clonePage
     *
     * Clones specific pages from a previously uploaded document to another previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClonePageParameters $pdf_clone_page_parameters A PdfClonePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfClonePageResponse
     */
    public function clonePage($pdf_clone_page_parameters)
    {
        list($response) = $this->clonePageWithHttpInfo($pdf_clone_page_parameters);
        return $response;
    }

    /**
     * Operation clonePageWithHttpInfo
     *
     * Clones specific pages from a previously uploaded document to another previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClonePageParameters $pdf_clone_page_parameters A PdfClonePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfClonePageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clonePageWithHttpInfo($pdf_clone_page_parameters)
    {
        $request = $this->clonePageRequest($pdf_clone_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfClonePageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfClonePageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfClonePageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfClonePageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clonePageAsync
     *
     * Clones specific pages from a previously uploaded document to another previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClonePageParameters $pdf_clone_page_parameters A PdfClonePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clonePageAsync($pdf_clone_page_parameters)
    {
        return $this->clonePageAsyncWithHttpInfo($pdf_clone_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clonePageAsyncWithHttpInfo
     *
     * Clones specific pages from a previously uploaded document to another previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfClonePageParameters $pdf_clone_page_parameters A PdfClonePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clonePageAsyncWithHttpInfo($pdf_clone_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfClonePageResponse';
        $request = $this->clonePageRequest($pdf_clone_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clonePage'
     *
     * @param  \OpenAPI\Client\Model\PdfClonePageParameters $pdf_clone_page_parameters A PdfClonePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clonePageRequest($pdf_clone_page_parameters)
    {
        // verify the required parameter 'pdf_clone_page_parameters' is set
        if ($pdf_clone_page_parameters === null || (is_array($pdf_clone_page_parameters) && count($pdf_clone_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_clone_page_parameters when calling clonePage'
            );
        }

        $resourcePath = '/api/pdf/ClonePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_clone_page_parameters)) {
            $_tempBody = $pdf_clone_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation closePDF
     *
     * Closes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfCloseDocumentParameters $pdf_close_document_parameters A PdfCloseDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfCloseDocumentResponse
     */
    public function closePDF($pdf_close_document_parameters)
    {
        list($response) = $this->closePDFWithHttpInfo($pdf_close_document_parameters);
        return $response;
    }

    /**
     * Operation closePDFWithHttpInfo
     *
     * Closes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfCloseDocumentParameters $pdf_close_document_parameters A PdfCloseDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfCloseDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function closePDFWithHttpInfo($pdf_close_document_parameters)
    {
        $request = $this->closePDFRequest($pdf_close_document_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfCloseDocumentResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfCloseDocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfCloseDocumentResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfCloseDocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation closePDFAsync
     *
     * Closes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfCloseDocumentParameters $pdf_close_document_parameters A PdfCloseDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closePDFAsync($pdf_close_document_parameters)
    {
        return $this->closePDFAsyncWithHttpInfo($pdf_close_document_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation closePDFAsyncWithHttpInfo
     *
     * Closes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfCloseDocumentParameters $pdf_close_document_parameters A PdfCloseDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closePDFAsyncWithHttpInfo($pdf_close_document_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfCloseDocumentResponse';
        $request = $this->closePDFRequest($pdf_close_document_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'closePDF'
     *
     * @param  \OpenAPI\Client\Model\PdfCloseDocumentParameters $pdf_close_document_parameters A PdfCloseDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function closePDFRequest($pdf_close_document_parameters)
    {
        // verify the required parameter 'pdf_close_document_parameters' is set
        if ($pdf_close_document_parameters === null || (is_array($pdf_close_document_parameters) && count($pdf_close_document_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_close_document_parameters when calling closePDF'
            );
        }

        $resourcePath = '/api/pdf/ClosePDF';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_close_document_parameters)) {
            $_tempBody = $pdf_close_document_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation convertToPDFA
     *
     * Converts a previously uploaded document to PDF/A.
     *
     * @param  \OpenAPI\Client\Model\PdfConvertToPDFAParameters $pdf_convert_to_pdfa_parameters A PdfConvertToPDFAParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfConvertToPDFAResponse
     */
    public function convertToPDFA($pdf_convert_to_pdfa_parameters)
    {
        list($response) = $this->convertToPDFAWithHttpInfo($pdf_convert_to_pdfa_parameters);
        return $response;
    }

    /**
     * Operation convertToPDFAWithHttpInfo
     *
     * Converts a previously uploaded document to PDF/A.
     *
     * @param  \OpenAPI\Client\Model\PdfConvertToPDFAParameters $pdf_convert_to_pdfa_parameters A PdfConvertToPDFAParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfConvertToPDFAResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function convertToPDFAWithHttpInfo($pdf_convert_to_pdfa_parameters)
    {
        $request = $this->convertToPDFARequest($pdf_convert_to_pdfa_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfConvertToPDFAResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfConvertToPDFAResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfConvertToPDFAResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfConvertToPDFAResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation convertToPDFAAsync
     *
     * Converts a previously uploaded document to PDF/A.
     *
     * @param  \OpenAPI\Client\Model\PdfConvertToPDFAParameters $pdf_convert_to_pdfa_parameters A PdfConvertToPDFAParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertToPDFAAsync($pdf_convert_to_pdfa_parameters)
    {
        return $this->convertToPDFAAsyncWithHttpInfo($pdf_convert_to_pdfa_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation convertToPDFAAsyncWithHttpInfo
     *
     * Converts a previously uploaded document to PDF/A.
     *
     * @param  \OpenAPI\Client\Model\PdfConvertToPDFAParameters $pdf_convert_to_pdfa_parameters A PdfConvertToPDFAParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertToPDFAAsyncWithHttpInfo($pdf_convert_to_pdfa_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfConvertToPDFAResponse';
        $request = $this->convertToPDFARequest($pdf_convert_to_pdfa_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'convertToPDFA'
     *
     * @param  \OpenAPI\Client\Model\PdfConvertToPDFAParameters $pdf_convert_to_pdfa_parameters A PdfConvertToPDFAParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function convertToPDFARequest($pdf_convert_to_pdfa_parameters)
    {
        // verify the required parameter 'pdf_convert_to_pdfa_parameters' is set
        if ($pdf_convert_to_pdfa_parameters === null || (is_array($pdf_convert_to_pdfa_parameters) && count($pdf_convert_to_pdfa_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_convert_to_pdfa_parameters when calling convertToPDFA'
            );
        }

        $resourcePath = '/api/pdf/ConvertToPDFA';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_convert_to_pdfa_parameters)) {
            $_tempBody = $pdf_convert_to_pdfa_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePage
     *
     * Deletes a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDeletePageParameters $pdf_delete_page_parameters A PdfDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfDeletePageResponse
     */
    public function deletePage($pdf_delete_page_parameters)
    {
        list($response) = $this->deletePageWithHttpInfo($pdf_delete_page_parameters);
        return $response;
    }

    /**
     * Operation deletePageWithHttpInfo
     *
     * Deletes a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDeletePageParameters $pdf_delete_page_parameters A PdfDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfDeletePageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageWithHttpInfo($pdf_delete_page_parameters)
    {
        $request = $this->deletePageRequest($pdf_delete_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfDeletePageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfDeletePageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfDeletePageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfDeletePageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageAsync
     *
     * Deletes a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDeletePageParameters $pdf_delete_page_parameters A PdfDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsync($pdf_delete_page_parameters)
    {
        return $this->deletePageAsyncWithHttpInfo($pdf_delete_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageAsyncWithHttpInfo
     *
     * Deletes a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDeletePageParameters $pdf_delete_page_parameters A PdfDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsyncWithHttpInfo($pdf_delete_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfDeletePageResponse';
        $request = $this->deletePageRequest($pdf_delete_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePage'
     *
     * @param  \OpenAPI\Client\Model\PdfDeletePageParameters $pdf_delete_page_parameters A PdfDeletePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageRequest($pdf_delete_page_parameters)
    {
        // verify the required parameter 'pdf_delete_page_parameters' is set
        if ($pdf_delete_page_parameters === null || (is_array($pdf_delete_page_parameters) && count($pdf_delete_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_delete_page_parameters when calling deletePage'
            );
        }

        $resourcePath = '/api/pdf/DeletePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_delete_page_parameters)) {
            $_tempBody = $pdf_delete_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation detectPageOrientation
     *
     * Detects the orientation of the page(s) of a previously uploaded document and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\PdfDetectPageOrientationParameters $pdf_detect_page_orientation_parameters A PdfDetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfDetectPageOrientationResponse
     */
    public function detectPageOrientation($pdf_detect_page_orientation_parameters)
    {
        list($response) = $this->detectPageOrientationWithHttpInfo($pdf_detect_page_orientation_parameters);
        return $response;
    }

    /**
     * Operation detectPageOrientationWithHttpInfo
     *
     * Detects the orientation of the page(s) of a previously uploaded document and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\PdfDetectPageOrientationParameters $pdf_detect_page_orientation_parameters A PdfDetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfDetectPageOrientationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function detectPageOrientationWithHttpInfo($pdf_detect_page_orientation_parameters)
    {
        $request = $this->detectPageOrientationRequest($pdf_detect_page_orientation_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfDetectPageOrientationResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfDetectPageOrientationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfDetectPageOrientationResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfDetectPageOrientationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation detectPageOrientationAsync
     *
     * Detects the orientation of the page(s) of a previously uploaded document and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\PdfDetectPageOrientationParameters $pdf_detect_page_orientation_parameters A PdfDetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectPageOrientationAsync($pdf_detect_page_orientation_parameters)
    {
        return $this->detectPageOrientationAsyncWithHttpInfo($pdf_detect_page_orientation_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation detectPageOrientationAsyncWithHttpInfo
     *
     * Detects the orientation of the page(s) of a previously uploaded document and offers to automatically rotate them.
     *
     * @param  \OpenAPI\Client\Model\PdfDetectPageOrientationParameters $pdf_detect_page_orientation_parameters A PdfDetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectPageOrientationAsyncWithHttpInfo($pdf_detect_page_orientation_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfDetectPageOrientationResponse';
        $request = $this->detectPageOrientationRequest($pdf_detect_page_orientation_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'detectPageOrientation'
     *
     * @param  \OpenAPI\Client\Model\PdfDetectPageOrientationParameters $pdf_detect_page_orientation_parameters A PdfDetectPageOrientationParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function detectPageOrientationRequest($pdf_detect_page_orientation_parameters)
    {
        // verify the required parameter 'pdf_detect_page_orientation_parameters' is set
        if ($pdf_detect_page_orientation_parameters === null || (is_array($pdf_detect_page_orientation_parameters) && count($pdf_detect_page_orientation_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_detect_page_orientation_parameters when calling detectPageOrientation'
            );
        }

        $resourcePath = '/api/pdf/DetectPageOrientation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_detect_page_orientation_parameters)) {
            $_tempBody = $pdf_detect_page_orientation_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation digiSign
     *
     * Signs a previously uploaded document digitally.
     *
     * @param  \OpenAPI\Client\Model\PdfDigiSignParameters $pdf_digi_sign_parameters A PdfDigiSignParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfDigiSignResponse
     */
    public function digiSign($pdf_digi_sign_parameters)
    {
        list($response) = $this->digiSignWithHttpInfo($pdf_digi_sign_parameters);
        return $response;
    }

    /**
     * Operation digiSignWithHttpInfo
     *
     * Signs a previously uploaded document digitally.
     *
     * @param  \OpenAPI\Client\Model\PdfDigiSignParameters $pdf_digi_sign_parameters A PdfDigiSignParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfDigiSignResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function digiSignWithHttpInfo($pdf_digi_sign_parameters)
    {
        $request = $this->digiSignRequest($pdf_digi_sign_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfDigiSignResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfDigiSignResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfDigiSignResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfDigiSignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation digiSignAsync
     *
     * Signs a previously uploaded document digitally.
     *
     * @param  \OpenAPI\Client\Model\PdfDigiSignParameters $pdf_digi_sign_parameters A PdfDigiSignParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function digiSignAsync($pdf_digi_sign_parameters)
    {
        return $this->digiSignAsyncWithHttpInfo($pdf_digi_sign_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation digiSignAsyncWithHttpInfo
     *
     * Signs a previously uploaded document digitally.
     *
     * @param  \OpenAPI\Client\Model\PdfDigiSignParameters $pdf_digi_sign_parameters A PdfDigiSignParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function digiSignAsyncWithHttpInfo($pdf_digi_sign_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfDigiSignResponse';
        $request = $this->digiSignRequest($pdf_digi_sign_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'digiSign'
     *
     * @param  \OpenAPI\Client\Model\PdfDigiSignParameters $pdf_digi_sign_parameters A PdfDigiSignParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function digiSignRequest($pdf_digi_sign_parameters)
    {
        // verify the required parameter 'pdf_digi_sign_parameters' is set
        if ($pdf_digi_sign_parameters === null || (is_array($pdf_digi_sign_parameters) && count($pdf_digi_sign_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_digi_sign_parameters when calling digiSign'
            );
        }

        $resourcePath = '/api/pdf/DigiSign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_digi_sign_parameters)) {
            $_tempBody = $pdf_digi_sign_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation drawImage
     *
     * Draws an image on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDrawImageParameters $pdf_draw_image_parameters A PdfDrawImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfDrawImageResponse
     */
    public function drawImage($pdf_draw_image_parameters)
    {
        list($response) = $this->drawImageWithHttpInfo($pdf_draw_image_parameters);
        return $response;
    }

    /**
     * Operation drawImageWithHttpInfo
     *
     * Draws an image on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDrawImageParameters $pdf_draw_image_parameters A PdfDrawImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfDrawImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function drawImageWithHttpInfo($pdf_draw_image_parameters)
    {
        $request = $this->drawImageRequest($pdf_draw_image_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfDrawImageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfDrawImageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfDrawImageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfDrawImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation drawImageAsync
     *
     * Draws an image on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDrawImageParameters $pdf_draw_image_parameters A PdfDrawImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function drawImageAsync($pdf_draw_image_parameters)
    {
        return $this->drawImageAsyncWithHttpInfo($pdf_draw_image_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation drawImageAsyncWithHttpInfo
     *
     * Draws an image on a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfDrawImageParameters $pdf_draw_image_parameters A PdfDrawImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function drawImageAsyncWithHttpInfo($pdf_draw_image_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfDrawImageResponse';
        $request = $this->drawImageRequest($pdf_draw_image_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'drawImage'
     *
     * @param  \OpenAPI\Client\Model\PdfDrawImageParameters $pdf_draw_image_parameters A PdfDrawImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function drawImageRequest($pdf_draw_image_parameters)
    {
        // verify the required parameter 'pdf_draw_image_parameters' is set
        if ($pdf_draw_image_parameters === null || (is_array($pdf_draw_image_parameters) && count($pdf_draw_image_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_draw_image_parameters when calling drawImage'
            );
        }

        $resourcePath = '/api/pdf/DrawImage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_draw_image_parameters)) {
            $_tempBody = $pdf_draw_image_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractPage
     *
     * Extracts a page range from a previously uploaded document into one or several new documents.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractPageParameters $pdf_extract_page_parameters A PdfExtractPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfExtractPageResponse
     */
    public function extractPage($pdf_extract_page_parameters)
    {
        list($response) = $this->extractPageWithHttpInfo($pdf_extract_page_parameters);
        return $response;
    }

    /**
     * Operation extractPageWithHttpInfo
     *
     * Extracts a page range from a previously uploaded document into one or several new documents.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractPageParameters $pdf_extract_page_parameters A PdfExtractPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfExtractPageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractPageWithHttpInfo($pdf_extract_page_parameters)
    {
        $request = $this->extractPageRequest($pdf_extract_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfExtractPageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfExtractPageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfExtractPageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfExtractPageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extractPageAsync
     *
     * Extracts a page range from a previously uploaded document into one or several new documents.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractPageParameters $pdf_extract_page_parameters A PdfExtractPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractPageAsync($pdf_extract_page_parameters)
    {
        return $this->extractPageAsyncWithHttpInfo($pdf_extract_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractPageAsyncWithHttpInfo
     *
     * Extracts a page range from a previously uploaded document into one or several new documents.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractPageParameters $pdf_extract_page_parameters A PdfExtractPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractPageAsyncWithHttpInfo($pdf_extract_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfExtractPageResponse';
        $request = $this->extractPageRequest($pdf_extract_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractPage'
     *
     * @param  \OpenAPI\Client\Model\PdfExtractPageParameters $pdf_extract_page_parameters A PdfExtractPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function extractPageRequest($pdf_extract_page_parameters)
    {
        // verify the required parameter 'pdf_extract_page_parameters' is set
        if ($pdf_extract_page_parameters === null || (is_array($pdf_extract_page_parameters) && count($pdf_extract_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_extract_page_parameters when calling extractPage'
            );
        }

        $resourcePath = '/api/pdf/ExtractPage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_extract_page_parameters)) {
            $_tempBody = $pdf_extract_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractText
     *
     * Extracts text from the document pages.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractTextParameters $pdf_extract_text_parameters A PdfExtractTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfExtractTextResponse
     */
    public function extractText($pdf_extract_text_parameters)
    {
        list($response) = $this->extractTextWithHttpInfo($pdf_extract_text_parameters);
        return $response;
    }

    /**
     * Operation extractTextWithHttpInfo
     *
     * Extracts text from the document pages.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractTextParameters $pdf_extract_text_parameters A PdfExtractTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfExtractTextResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractTextWithHttpInfo($pdf_extract_text_parameters)
    {
        $request = $this->extractTextRequest($pdf_extract_text_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfExtractTextResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfExtractTextResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfExtractTextResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfExtractTextResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extractTextAsync
     *
     * Extracts text from the document pages.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractTextParameters $pdf_extract_text_parameters A PdfExtractTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractTextAsync($pdf_extract_text_parameters)
    {
        return $this->extractTextAsyncWithHttpInfo($pdf_extract_text_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractTextAsyncWithHttpInfo
     *
     * Extracts text from the document pages.
     *
     * @param  \OpenAPI\Client\Model\PdfExtractTextParameters $pdf_extract_text_parameters A PdfExtractTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractTextAsyncWithHttpInfo($pdf_extract_text_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfExtractTextResponse';
        $request = $this->extractTextRequest($pdf_extract_text_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractText'
     *
     * @param  \OpenAPI\Client\Model\PdfExtractTextParameters $pdf_extract_text_parameters A PdfExtractTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function extractTextRequest($pdf_extract_text_parameters)
    {
        // verify the required parameter 'pdf_extract_text_parameters' is set
        if ($pdf_extract_text_parameters === null || (is_array($pdf_extract_text_parameters) && count($pdf_extract_text_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_extract_text_parameters when calling extractText'
            );
        }

        $resourcePath = '/api/pdf/ExtractText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_extract_text_parameters)) {
            $_tempBody = $pdf_extract_text_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation flatten
     *
     * Flattens the form-fields, annotations, and/or the layers of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfFlattenParameters $pdf_flatten_parameters A PdfFlatten object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfFlattenResponse
     */
    public function flatten($pdf_flatten_parameters)
    {
        list($response) = $this->flattenWithHttpInfo($pdf_flatten_parameters);
        return $response;
    }

    /**
     * Operation flattenWithHttpInfo
     *
     * Flattens the form-fields, annotations, and/or the layers of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfFlattenParameters $pdf_flatten_parameters A PdfFlatten object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfFlattenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function flattenWithHttpInfo($pdf_flatten_parameters)
    {
        $request = $this->flattenRequest($pdf_flatten_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfFlattenResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfFlattenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfFlattenResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfFlattenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation flattenAsync
     *
     * Flattens the form-fields, annotations, and/or the layers of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfFlattenParameters $pdf_flatten_parameters A PdfFlatten object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flattenAsync($pdf_flatten_parameters)
    {
        return $this->flattenAsyncWithHttpInfo($pdf_flatten_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation flattenAsyncWithHttpInfo
     *
     * Flattens the form-fields, annotations, and/or the layers of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfFlattenParameters $pdf_flatten_parameters A PdfFlatten object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flattenAsyncWithHttpInfo($pdf_flatten_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfFlattenResponse';
        $request = $this->flattenRequest($pdf_flatten_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'flatten'
     *
     * @param  \OpenAPI\Client\Model\PdfFlattenParameters $pdf_flatten_parameters A PdfFlatten object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function flattenRequest($pdf_flatten_parameters)
    {
        // verify the required parameter 'pdf_flatten_parameters' is set
        if ($pdf_flatten_parameters === null || (is_array($pdf_flatten_parameters) && count($pdf_flatten_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_flatten_parameters when calling flatten'
            );
        }

        $resourcePath = '/api/pdf/Flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_flatten_parameters)) {
            $_tempBody = $pdf_flatten_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInfo
     *
     * Gets information about a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetInfoParameters $pdf_get_info_parameters A PdfGetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfGetInfoResponse
     */
    public function getInfo($pdf_get_info_parameters)
    {
        list($response) = $this->getInfoWithHttpInfo($pdf_get_info_parameters);
        return $response;
    }

    /**
     * Operation getInfoWithHttpInfo
     *
     * Gets information about a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetInfoParameters $pdf_get_info_parameters A PdfGetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfGetInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInfoWithHttpInfo($pdf_get_info_parameters)
    {
        $request = $this->getInfoRequest($pdf_get_info_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfGetInfoResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfGetInfoResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfGetInfoResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfGetInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInfoAsync
     *
     * Gets information about a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetInfoParameters $pdf_get_info_parameters A PdfGetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInfoAsync($pdf_get_info_parameters)
    {
        return $this->getInfoAsyncWithHttpInfo($pdf_get_info_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInfoAsyncWithHttpInfo
     *
     * Gets information about a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetInfoParameters $pdf_get_info_parameters A PdfGetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInfoAsyncWithHttpInfo($pdf_get_info_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfGetInfoResponse';
        $request = $this->getInfoRequest($pdf_get_info_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInfo'
     *
     * @param  \OpenAPI\Client\Model\PdfGetInfoParameters $pdf_get_info_parameters A PdfGetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInfoRequest($pdf_get_info_parameters)
    {
        // verify the required parameter 'pdf_get_info_parameters' is set
        if ($pdf_get_info_parameters === null || (is_array($pdf_get_info_parameters) && count($pdf_get_info_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_get_info_parameters when calling getInfo'
            );
        }

        $resourcePath = '/api/pdf/GetInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_get_info_parameters)) {
            $_tempBody = $pdf_get_info_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPDFImportSupportedFileExtensions
     *
     * Gets the supported file extensions by the LoadDocumentAsPDF action.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringArrayResponse
     */
    public function getPDFImportSupportedFileExtensions()
    {
        list($response) = $this->getPDFImportSupportedFileExtensionsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getPDFImportSupportedFileExtensionsWithHttpInfo
     *
     * Gets the supported file extensions by the LoadDocumentAsPDF action.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringArrayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPDFImportSupportedFileExtensionsWithHttpInfo()
    {
        $request = $this->getPDFImportSupportedFileExtensionsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StringArrayResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StringArrayResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\StringArrayResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringArrayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPDFImportSupportedFileExtensionsAsync
     *
     * Gets the supported file extensions by the LoadDocumentAsPDF action.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPDFImportSupportedFileExtensionsAsync()
    {
        return $this->getPDFImportSupportedFileExtensionsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPDFImportSupportedFileExtensionsAsyncWithHttpInfo
     *
     * Gets the supported file extensions by the LoadDocumentAsPDF action.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPDFImportSupportedFileExtensionsAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\StringArrayResponse';
        $request = $this->getPDFImportSupportedFileExtensionsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPDFImportSupportedFileExtensions'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPDFImportSupportedFileExtensionsRequest()
    {

        $resourcePath = '/api/pdf/GetPDFImportSupportedFileExtensions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageThumbnail
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetPageThumbnailParameters $pdf_get_page_thumbnail_parameters A PdfGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfGetPageThumbnailResponse
     */
    public function getPageThumbnail($pdf_get_page_thumbnail_parameters)
    {
        list($response) = $this->getPageThumbnailWithHttpInfo($pdf_get_page_thumbnail_parameters);
        return $response;
    }

    /**
     * Operation getPageThumbnailWithHttpInfo
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetPageThumbnailParameters $pdf_get_page_thumbnail_parameters A PdfGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfGetPageThumbnailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageThumbnailWithHttpInfo($pdf_get_page_thumbnail_parameters)
    {
        $request = $this->getPageThumbnailRequest($pdf_get_page_thumbnail_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfGetPageThumbnailResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfGetPageThumbnailResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfGetPageThumbnailResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfGetPageThumbnailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageThumbnailAsync
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetPageThumbnailParameters $pdf_get_page_thumbnail_parameters A PdfGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageThumbnailAsync($pdf_get_page_thumbnail_parameters)
    {
        return $this->getPageThumbnailAsyncWithHttpInfo($pdf_get_page_thumbnail_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageThumbnailAsyncWithHttpInfo
     *
     * Gets a thumbnail of each page within the provided page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfGetPageThumbnailParameters $pdf_get_page_thumbnail_parameters A PdfGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageThumbnailAsyncWithHttpInfo($pdf_get_page_thumbnail_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfGetPageThumbnailResponse';
        $request = $this->getPageThumbnailRequest($pdf_get_page_thumbnail_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageThumbnail'
     *
     * @param  \OpenAPI\Client\Model\PdfGetPageThumbnailParameters $pdf_get_page_thumbnail_parameters A PdfGetPageThumbnailParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageThumbnailRequest($pdf_get_page_thumbnail_parameters)
    {
        // verify the required parameter 'pdf_get_page_thumbnail_parameters' is set
        if ($pdf_get_page_thumbnail_parameters === null || (is_array($pdf_get_page_thumbnail_parameters) && count($pdf_get_page_thumbnail_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_get_page_thumbnail_parameters when calling getPageThumbnail'
            );
        }

        $resourcePath = '/api/pdf/GetPageThumbnail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_get_page_thumbnail_parameters)) {
            $_tempBody = $pdf_get_page_thumbnail_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertImage
     *
     * Inserts an image on a new page of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertImageParameters $pdf_insert_image_parameters A PdfInsertImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfInsertImageResponse
     */
    public function insertImage($pdf_insert_image_parameters)
    {
        list($response) = $this->insertImageWithHttpInfo($pdf_insert_image_parameters);
        return $response;
    }

    /**
     * Operation insertImageWithHttpInfo
     *
     * Inserts an image on a new page of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertImageParameters $pdf_insert_image_parameters A PdfInsertImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfInsertImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertImageWithHttpInfo($pdf_insert_image_parameters)
    {
        $request = $this->insertImageRequest($pdf_insert_image_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfInsertImageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfInsertImageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfInsertImageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfInsertImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertImageAsync
     *
     * Inserts an image on a new page of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertImageParameters $pdf_insert_image_parameters A PdfInsertImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertImageAsync($pdf_insert_image_parameters)
    {
        return $this->insertImageAsyncWithHttpInfo($pdf_insert_image_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertImageAsyncWithHttpInfo
     *
     * Inserts an image on a new page of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertImageParameters $pdf_insert_image_parameters A PdfInsertImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertImageAsyncWithHttpInfo($pdf_insert_image_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfInsertImageResponse';
        $request = $this->insertImageRequest($pdf_insert_image_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertImage'
     *
     * @param  \OpenAPI\Client\Model\PdfInsertImageParameters $pdf_insert_image_parameters A PdfInsertImageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertImageRequest($pdf_insert_image_parameters)
    {
        // verify the required parameter 'pdf_insert_image_parameters' is set
        if ($pdf_insert_image_parameters === null || (is_array($pdf_insert_image_parameters) && count($pdf_insert_image_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_insert_image_parameters when calling insertImage'
            );
        }

        $resourcePath = '/api/pdf/InsertImage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_insert_image_parameters)) {
            $_tempBody = $pdf_insert_image_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertNewPage
     *
     * Inserts one or more new blank pages to a specific position in a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertNewPageParameters $pdf_insert_new_page_parameters A PdfInsertNewPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfInsertNewPageResponse
     */
    public function insertNewPage($pdf_insert_new_page_parameters)
    {
        list($response) = $this->insertNewPageWithHttpInfo($pdf_insert_new_page_parameters);
        return $response;
    }

    /**
     * Operation insertNewPageWithHttpInfo
     *
     * Inserts one or more new blank pages to a specific position in a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertNewPageParameters $pdf_insert_new_page_parameters A PdfInsertNewPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfInsertNewPageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertNewPageWithHttpInfo($pdf_insert_new_page_parameters)
    {
        $request = $this->insertNewPageRequest($pdf_insert_new_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfInsertNewPageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfInsertNewPageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfInsertNewPageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfInsertNewPageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertNewPageAsync
     *
     * Inserts one or more new blank pages to a specific position in a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertNewPageParameters $pdf_insert_new_page_parameters A PdfInsertNewPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertNewPageAsync($pdf_insert_new_page_parameters)
    {
        return $this->insertNewPageAsyncWithHttpInfo($pdf_insert_new_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertNewPageAsyncWithHttpInfo
     *
     * Inserts one or more new blank pages to a specific position in a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertNewPageParameters $pdf_insert_new_page_parameters A PdfInsertNewPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertNewPageAsyncWithHttpInfo($pdf_insert_new_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfInsertNewPageResponse';
        $request = $this->insertNewPageRequest($pdf_insert_new_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertNewPage'
     *
     * @param  \OpenAPI\Client\Model\PdfInsertNewPageParameters $pdf_insert_new_page_parameters A PdfInsertNewPageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertNewPageRequest($pdf_insert_new_page_parameters)
    {
        // verify the required parameter 'pdf_insert_new_page_parameters' is set
        if ($pdf_insert_new_page_parameters === null || (is_array($pdf_insert_new_page_parameters) && count($pdf_insert_new_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_insert_new_page_parameters when calling insertNewPage'
            );
        }

        $resourcePath = '/api/pdf/InsertNewPage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_insert_new_page_parameters)) {
            $_tempBody = $pdf_insert_new_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPageNumber
     *
     * Inserts page number(s) on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertPageNumberParameters $pdf_insert_page_number_parameters A PdfInsertPageNumberParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfInsertPageNumberResponse
     */
    public function insertPageNumber($pdf_insert_page_number_parameters)
    {
        list($response) = $this->insertPageNumberWithHttpInfo($pdf_insert_page_number_parameters);
        return $response;
    }

    /**
     * Operation insertPageNumberWithHttpInfo
     *
     * Inserts page number(s) on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertPageNumberParameters $pdf_insert_page_number_parameters A PdfInsertPageNumberParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfInsertPageNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPageNumberWithHttpInfo($pdf_insert_page_number_parameters)
    {
        $request = $this->insertPageNumberRequest($pdf_insert_page_number_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfInsertPageNumberResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfInsertPageNumberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfInsertPageNumberResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfInsertPageNumberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPageNumberAsync
     *
     * Inserts page number(s) on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertPageNumberParameters $pdf_insert_page_number_parameters A PdfInsertPageNumberParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPageNumberAsync($pdf_insert_page_number_parameters)
    {
        return $this->insertPageNumberAsyncWithHttpInfo($pdf_insert_page_number_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPageNumberAsyncWithHttpInfo
     *
     * Inserts page number(s) on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertPageNumberParameters $pdf_insert_page_number_parameters A PdfInsertPageNumberParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPageNumberAsyncWithHttpInfo($pdf_insert_page_number_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfInsertPageNumberResponse';
        $request = $this->insertPageNumberRequest($pdf_insert_page_number_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPageNumber'
     *
     * @param  \OpenAPI\Client\Model\PdfInsertPageNumberParameters $pdf_insert_page_number_parameters A PdfInsertPageNumberParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPageNumberRequest($pdf_insert_page_number_parameters)
    {
        // verify the required parameter 'pdf_insert_page_number_parameters' is set
        if ($pdf_insert_page_number_parameters === null || (is_array($pdf_insert_page_number_parameters) && count($pdf_insert_page_number_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_insert_page_number_parameters when calling insertPageNumber'
            );
        }

        $resourcePath = '/api/pdf/InsertPageNumber';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_insert_page_number_parameters)) {
            $_tempBody = $pdf_insert_page_number_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertText
     *
     * Inserts text on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertTextParameters $pdf_insert_text_parameters A PdfInsertTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfInsertTextResponse
     */
    public function insertText($pdf_insert_text_parameters)
    {
        list($response) = $this->insertTextWithHttpInfo($pdf_insert_text_parameters);
        return $response;
    }

    /**
     * Operation insertTextWithHttpInfo
     *
     * Inserts text on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertTextParameters $pdf_insert_text_parameters A PdfInsertTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfInsertTextResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertTextWithHttpInfo($pdf_insert_text_parameters)
    {
        $request = $this->insertTextRequest($pdf_insert_text_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfInsertTextResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfInsertTextResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfInsertTextResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfInsertTextResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertTextAsync
     *
     * Inserts text on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertTextParameters $pdf_insert_text_parameters A PdfInsertTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTextAsync($pdf_insert_text_parameters)
    {
        return $this->insertTextAsyncWithHttpInfo($pdf_insert_text_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertTextAsyncWithHttpInfo
     *
     * Inserts text on a document.
     *
     * @param  \OpenAPI\Client\Model\PdfInsertTextParameters $pdf_insert_text_parameters A PdfInsertTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTextAsyncWithHttpInfo($pdf_insert_text_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfInsertTextResponse';
        $request = $this->insertTextRequest($pdf_insert_text_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertText'
     *
     * @param  \OpenAPI\Client\Model\PdfInsertTextParameters $pdf_insert_text_parameters A PdfInsertTextParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertTextRequest($pdf_insert_text_parameters)
    {
        // verify the required parameter 'pdf_insert_text_parameters' is set
        if ($pdf_insert_text_parameters === null || (is_array($pdf_insert_text_parameters) && count($pdf_insert_text_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_insert_text_parameters when calling insertText'
            );
        }

        $resourcePath = '/api/pdf/InsertText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_insert_text_parameters)) {
            $_tempBody = $pdf_insert_text_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation linearize
     *
     * Linearizes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfLinearizeParameters $pdf_linearize_parameters A PdfLinearizeParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfLinearizeResponse
     */
    public function linearize($pdf_linearize_parameters)
    {
        list($response) = $this->linearizeWithHttpInfo($pdf_linearize_parameters);
        return $response;
    }

    /**
     * Operation linearizeWithHttpInfo
     *
     * Linearizes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfLinearizeParameters $pdf_linearize_parameters A PdfLinearizeParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfLinearizeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function linearizeWithHttpInfo($pdf_linearize_parameters)
    {
        $request = $this->linearizeRequest($pdf_linearize_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfLinearizeResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfLinearizeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfLinearizeResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfLinearizeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation linearizeAsync
     *
     * Linearizes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfLinearizeParameters $pdf_linearize_parameters A PdfLinearizeParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linearizeAsync($pdf_linearize_parameters)
    {
        return $this->linearizeAsyncWithHttpInfo($pdf_linearize_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation linearizeAsyncWithHttpInfo
     *
     * Linearizes a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfLinearizeParameters $pdf_linearize_parameters A PdfLinearizeParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linearizeAsyncWithHttpInfo($pdf_linearize_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfLinearizeResponse';
        $request = $this->linearizeRequest($pdf_linearize_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'linearize'
     *
     * @param  \OpenAPI\Client\Model\PdfLinearizeParameters $pdf_linearize_parameters A PdfLinearizeParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function linearizeRequest($pdf_linearize_parameters)
    {
        // verify the required parameter 'pdf_linearize_parameters' is set
        if ($pdf_linearize_parameters === null || (is_array($pdf_linearize_parameters) && count($pdf_linearize_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_linearize_parameters when calling linearize'
            );
        }

        $resourcePath = '/api/pdf/Linearize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_linearize_parameters)) {
            $_tempBody = $pdf_linearize_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation loadDocumentAsPDF
     *
     * Imports the provided document as PDF.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentFromByteArrayParameters $pdf_load_document_from_byte_array_parameters A PdfLoadDocumentFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfLoadDocumentResponse
     */
    public function loadDocumentAsPDF($pdf_load_document_from_byte_array_parameters)
    {
        list($response) = $this->loadDocumentAsPDFWithHttpInfo($pdf_load_document_from_byte_array_parameters);
        return $response;
    }

    /**
     * Operation loadDocumentAsPDFWithHttpInfo
     *
     * Imports the provided document as PDF.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentFromByteArrayParameters $pdf_load_document_from_byte_array_parameters A PdfLoadDocumentFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfLoadDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function loadDocumentAsPDFWithHttpInfo($pdf_load_document_from_byte_array_parameters)
    {
        $request = $this->loadDocumentAsPDFRequest($pdf_load_document_from_byte_array_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfLoadDocumentResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfLoadDocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfLoadDocumentResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfLoadDocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation loadDocumentAsPDFAsync
     *
     * Imports the provided document as PDF.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentFromByteArrayParameters $pdf_load_document_from_byte_array_parameters A PdfLoadDocumentFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loadDocumentAsPDFAsync($pdf_load_document_from_byte_array_parameters)
    {
        return $this->loadDocumentAsPDFAsyncWithHttpInfo($pdf_load_document_from_byte_array_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation loadDocumentAsPDFAsyncWithHttpInfo
     *
     * Imports the provided document as PDF.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentFromByteArrayParameters $pdf_load_document_from_byte_array_parameters A PdfLoadDocumentFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loadDocumentAsPDFAsyncWithHttpInfo($pdf_load_document_from_byte_array_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfLoadDocumentResponse';
        $request = $this->loadDocumentAsPDFRequest($pdf_load_document_from_byte_array_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'loadDocumentAsPDF'
     *
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentFromByteArrayParameters $pdf_load_document_from_byte_array_parameters A PdfLoadDocumentFromByteArrayParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function loadDocumentAsPDFRequest($pdf_load_document_from_byte_array_parameters)
    {
        // verify the required parameter 'pdf_load_document_from_byte_array_parameters' is set
        if ($pdf_load_document_from_byte_array_parameters === null || (is_array($pdf_load_document_from_byte_array_parameters) && count($pdf_load_document_from_byte_array_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_load_document_from_byte_array_parameters when calling loadDocumentAsPDF'
            );
        }

        $resourcePath = '/api/pdf/LoadDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_load_document_from_byte_array_parameters)) {
            $_tempBody = $pdf_load_document_from_byte_array_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation loadDocumentAsPDFMultipart
     *
     * Imports the provided document as PDF using Multipart Upload.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentParameters $load_document_parameters load_document_parameters (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfLoadDocumentResponse
     */
    public function loadDocumentAsPDFMultipart($file_data, $load_document_parameters = null)
    {
        list($response) = $this->loadDocumentAsPDFMultipartWithHttpInfo($file_data, $load_document_parameters);
        return $response;
    }

    /**
     * Operation loadDocumentAsPDFMultipartWithHttpInfo
     *
     * Imports the provided document as PDF using Multipart Upload.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentParameters $load_document_parameters (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfLoadDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function loadDocumentAsPDFMultipartWithHttpInfo($file_data, $load_document_parameters = null)
    {
        $request = $this->loadDocumentAsPDFMultipartRequest($file_data, $load_document_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfLoadDocumentResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfLoadDocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfLoadDocumentResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfLoadDocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation loadDocumentAsPDFMultipartAsync
     *
     * Imports the provided document as PDF using Multipart Upload.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentParameters $load_document_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loadDocumentAsPDFMultipartAsync($file_data, $load_document_parameters = null)
    {
        return $this->loadDocumentAsPDFMultipartAsyncWithHttpInfo($file_data, $load_document_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation loadDocumentAsPDFMultipartAsyncWithHttpInfo
     *
     * Imports the provided document as PDF using Multipart Upload.  Supported document formats can be retrieved by the GetPDFImportSupportedFileExtensions action.
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentParameters $load_document_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loadDocumentAsPDFMultipartAsyncWithHttpInfo($file_data, $load_document_parameters = null)
    {
        $returnType = '\OpenAPI\Client\Model\PdfLoadDocumentResponse';
        $request = $this->loadDocumentAsPDFMultipartRequest($file_data, $load_document_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'loadDocumentAsPDFMultipart'
     *
     * @param  \SplFileObject $file_data The data of the document. (required)
     * @param  \OpenAPI\Client\Model\PdfLoadDocumentParameters $load_document_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function loadDocumentAsPDFMultipartRequest($file_data, $load_document_parameters = null)
    {
        // verify the required parameter 'file_data' is set
        if ($file_data === null || (is_array($file_data) && count($file_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_data when calling loadDocumentAsPDFMultipart'
            );
        }

        $resourcePath = '/api/pdf/LoadDocumentAsPDFMultipart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($file_data !== null) {
            $multipart = true;
            $formParams['fileData'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file_data), 'rb');
        }
        // form params
        if ($load_document_parameters !== null) {
            $formParams['loadDocumentParameters'] = ObjectSerializer::toFormValue($load_document_parameters);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation merge
     *
     * Merges several previously uploaded documents into a new PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfMergeParameters $pdf_merge_parameters A PdfMergeParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfMergeResponse
     */
    public function merge($pdf_merge_parameters)
    {
        list($response) = $this->mergeWithHttpInfo($pdf_merge_parameters);
        return $response;
    }

    /**
     * Operation mergeWithHttpInfo
     *
     * Merges several previously uploaded documents into a new PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfMergeParameters $pdf_merge_parameters A PdfMergeParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfMergeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergeWithHttpInfo($pdf_merge_parameters)
    {
        $request = $this->mergeRequest($pdf_merge_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfMergeResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfMergeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfMergeResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfMergeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mergeAsync
     *
     * Merges several previously uploaded documents into a new PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfMergeParameters $pdf_merge_parameters A PdfMergeParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeAsync($pdf_merge_parameters)
    {
        return $this->mergeAsyncWithHttpInfo($pdf_merge_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergeAsyncWithHttpInfo
     *
     * Merges several previously uploaded documents into a new PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfMergeParameters $pdf_merge_parameters A PdfMergeParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeAsyncWithHttpInfo($pdf_merge_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfMergeResponse';
        $request = $this->mergeRequest($pdf_merge_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'merge'
     *
     * @param  \OpenAPI\Client\Model\PdfMergeParameters $pdf_merge_parameters A PdfMergeParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mergeRequest($pdf_merge_parameters)
    {
        // verify the required parameter 'pdf_merge_parameters' is set
        if ($pdf_merge_parameters === null || (is_array($pdf_merge_parameters) && count($pdf_merge_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_merge_parameters when calling merge'
            );
        }

        $resourcePath = '/api/pdf/Merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_merge_parameters)) {
            $_tempBody = $pdf_merge_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergePages
     *
     * Merges multiple pages, vertically, within a previously uploaded document into one single page.
     *
     * @param  \OpenAPI\Client\Model\PdfMergePagesParameters $pdf_merge_pages_parameters A PdfMergePages object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfMergePagesResponse
     */
    public function mergePages($pdf_merge_pages_parameters)
    {
        list($response) = $this->mergePagesWithHttpInfo($pdf_merge_pages_parameters);
        return $response;
    }

    /**
     * Operation mergePagesWithHttpInfo
     *
     * Merges multiple pages, vertically, within a previously uploaded document into one single page.
     *
     * @param  \OpenAPI\Client\Model\PdfMergePagesParameters $pdf_merge_pages_parameters A PdfMergePages object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfMergePagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergePagesWithHttpInfo($pdf_merge_pages_parameters)
    {
        $request = $this->mergePagesRequest($pdf_merge_pages_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfMergePagesResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfMergePagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfMergePagesResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfMergePagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mergePagesAsync
     *
     * Merges multiple pages, vertically, within a previously uploaded document into one single page.
     *
     * @param  \OpenAPI\Client\Model\PdfMergePagesParameters $pdf_merge_pages_parameters A PdfMergePages object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergePagesAsync($pdf_merge_pages_parameters)
    {
        return $this->mergePagesAsyncWithHttpInfo($pdf_merge_pages_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergePagesAsyncWithHttpInfo
     *
     * Merges multiple pages, vertically, within a previously uploaded document into one single page.
     *
     * @param  \OpenAPI\Client\Model\PdfMergePagesParameters $pdf_merge_pages_parameters A PdfMergePages object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergePagesAsyncWithHttpInfo($pdf_merge_pages_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfMergePagesResponse';
        $request = $this->mergePagesRequest($pdf_merge_pages_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergePages'
     *
     * @param  \OpenAPI\Client\Model\PdfMergePagesParameters $pdf_merge_pages_parameters A PdfMergePages object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mergePagesRequest($pdf_merge_pages_parameters)
    {
        // verify the required parameter 'pdf_merge_pages_parameters' is set
        if ($pdf_merge_pages_parameters === null || (is_array($pdf_merge_pages_parameters) && count($pdf_merge_pages_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_merge_pages_parameters when calling mergePages'
            );
        }

        $resourcePath = '/api/pdf/MergePages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_merge_pages_parameters)) {
            $_tempBody = $pdf_merge_pages_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation movePage
     *
     * Moves a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfMovePageParameters $pdf_move_page_parameters A PdfMovePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfMovePageResponse
     */
    public function movePage($pdf_move_page_parameters)
    {
        list($response) = $this->movePageWithHttpInfo($pdf_move_page_parameters);
        return $response;
    }

    /**
     * Operation movePageWithHttpInfo
     *
     * Moves a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfMovePageParameters $pdf_move_page_parameters A PdfMovePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfMovePageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function movePageWithHttpInfo($pdf_move_page_parameters)
    {
        $request = $this->movePageRequest($pdf_move_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfMovePageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfMovePageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfMovePageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfMovePageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation movePageAsync
     *
     * Moves a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfMovePageParameters $pdf_move_page_parameters A PdfMovePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function movePageAsync($pdf_move_page_parameters)
    {
        return $this->movePageAsyncWithHttpInfo($pdf_move_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation movePageAsyncWithHttpInfo
     *
     * Moves a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfMovePageParameters $pdf_move_page_parameters A PdfMovePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function movePageAsyncWithHttpInfo($pdf_move_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfMovePageResponse';
        $request = $this->movePageRequest($pdf_move_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'movePage'
     *
     * @param  \OpenAPI\Client\Model\PdfMovePageParameters $pdf_move_page_parameters A PdfMovePageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function movePageRequest($pdf_move_page_parameters)
    {
        // verify the required parameter 'pdf_move_page_parameters' is set
        if ($pdf_move_page_parameters === null || (is_array($pdf_move_page_parameters) && count($pdf_move_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_move_page_parameters when calling movePage'
            );
        }

        $resourcePath = '/api/pdf/MovePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_move_page_parameters)) {
            $_tempBody = $pdf_move_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation oCR
     *
     * Performs optical character recognition on a page range of a previously uploaded document.  The recognized text is added as invisible text on each processed page.  No token is charged for blank pages.
     *
     * @param  \OpenAPI\Client\Model\PdfOCRParameters $pdf_ocr_parameters A PdfOCRParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfOCRResponse
     */
    public function oCR($pdf_ocr_parameters)
    {
        list($response) = $this->oCRWithHttpInfo($pdf_ocr_parameters);
        return $response;
    }

    /**
     * Operation oCRWithHttpInfo
     *
     * Performs optical character recognition on a page range of a previously uploaded document.  The recognized text is added as invisible text on each processed page.  No token is charged for blank pages.
     *
     * @param  \OpenAPI\Client\Model\PdfOCRParameters $pdf_ocr_parameters A PdfOCRParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfOCRResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function oCRWithHttpInfo($pdf_ocr_parameters)
    {
        $request = $this->oCRRequest($pdf_ocr_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfOCRResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfOCRResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfOCRResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfOCRResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oCRAsync
     *
     * Performs optical character recognition on a page range of a previously uploaded document.  The recognized text is added as invisible text on each processed page.  No token is charged for blank pages.
     *
     * @param  \OpenAPI\Client\Model\PdfOCRParameters $pdf_ocr_parameters A PdfOCRParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oCRAsync($pdf_ocr_parameters)
    {
        return $this->oCRAsyncWithHttpInfo($pdf_ocr_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oCRAsyncWithHttpInfo
     *
     * Performs optical character recognition on a page range of a previously uploaded document.  The recognized text is added as invisible text on each processed page.  No token is charged for blank pages.
     *
     * @param  \OpenAPI\Client\Model\PdfOCRParameters $pdf_ocr_parameters A PdfOCRParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oCRAsyncWithHttpInfo($pdf_ocr_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfOCRResponse';
        $request = $this->oCRRequest($pdf_ocr_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oCR'
     *
     * @param  \OpenAPI\Client\Model\PdfOCRParameters $pdf_ocr_parameters A PdfOCRParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function oCRRequest($pdf_ocr_parameters)
    {
        // verify the required parameter 'pdf_ocr_parameters' is set
        if ($pdf_ocr_parameters === null || (is_array($pdf_ocr_parameters) && count($pdf_ocr_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_ocr_parameters when calling oCR'
            );
        }

        $resourcePath = '/api/pdf/OCR';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_ocr_parameters)) {
            $_tempBody = $pdf_ocr_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation protect
     *
     * Protects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfProtectParameters $pdf_protect_parameters A PdfProtectParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfProtectResponse
     */
    public function protect($pdf_protect_parameters)
    {
        list($response) = $this->protectWithHttpInfo($pdf_protect_parameters);
        return $response;
    }

    /**
     * Operation protectWithHttpInfo
     *
     * Protects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfProtectParameters $pdf_protect_parameters A PdfProtectParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfProtectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function protectWithHttpInfo($pdf_protect_parameters)
    {
        $request = $this->protectRequest($pdf_protect_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfProtectResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfProtectResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfProtectResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfProtectResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation protectAsync
     *
     * Protects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfProtectParameters $pdf_protect_parameters A PdfProtectParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function protectAsync($pdf_protect_parameters)
    {
        return $this->protectAsyncWithHttpInfo($pdf_protect_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation protectAsyncWithHttpInfo
     *
     * Protects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfProtectParameters $pdf_protect_parameters A PdfProtectParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function protectAsyncWithHttpInfo($pdf_protect_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfProtectResponse';
        $request = $this->protectRequest($pdf_protect_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'protect'
     *
     * @param  \OpenAPI\Client\Model\PdfProtectParameters $pdf_protect_parameters A PdfProtectParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function protectRequest($pdf_protect_parameters)
    {
        // verify the required parameter 'pdf_protect_parameters' is set
        if ($pdf_protect_parameters === null || (is_array($pdf_protect_parameters) && count($pdf_protect_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_protect_parameters when calling protect'
            );
        }

        $resourcePath = '/api/pdf/Protect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_protect_parameters)) {
            $_tempBody = $pdf_protect_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readBarcodes
     *
     * Reads barcodes from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReadBarcodesParameters $pdf_read_barcodes_parameters A PdfReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ReadBarcodesResponse
     */
    public function readBarcodes($pdf_read_barcodes_parameters)
    {
        list($response) = $this->readBarcodesWithHttpInfo($pdf_read_barcodes_parameters);
        return $response;
    }

    /**
     * Operation readBarcodesWithHttpInfo
     *
     * Reads barcodes from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReadBarcodesParameters $pdf_read_barcodes_parameters A PdfReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ReadBarcodesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function readBarcodesWithHttpInfo($pdf_read_barcodes_parameters)
    {
        $request = $this->readBarcodesRequest($pdf_read_barcodes_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ReadBarcodesResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ReadBarcodesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ReadBarcodesResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ReadBarcodesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readBarcodesAsync
     *
     * Reads barcodes from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReadBarcodesParameters $pdf_read_barcodes_parameters A PdfReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readBarcodesAsync($pdf_read_barcodes_parameters)
    {
        return $this->readBarcodesAsyncWithHttpInfo($pdf_read_barcodes_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readBarcodesAsyncWithHttpInfo
     *
     * Reads barcodes from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReadBarcodesParameters $pdf_read_barcodes_parameters A PdfReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readBarcodesAsyncWithHttpInfo($pdf_read_barcodes_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\ReadBarcodesResponse';
        $request = $this->readBarcodesRequest($pdf_read_barcodes_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readBarcodes'
     *
     * @param  \OpenAPI\Client\Model\PdfReadBarcodesParameters $pdf_read_barcodes_parameters A PdfReadBarcodesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readBarcodesRequest($pdf_read_barcodes_parameters)
    {
        // verify the required parameter 'pdf_read_barcodes_parameters' is set
        if ($pdf_read_barcodes_parameters === null || (is_array($pdf_read_barcodes_parameters) && count($pdf_read_barcodes_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_read_barcodes_parameters when calling readBarcodes'
            );
        }

        $resourcePath = '/api/pdf/ReadBarcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_read_barcodes_parameters)) {
            $_tempBody = $pdf_read_barcodes_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reduce
     *
     * Reduces the size of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReduceParameters $pdf_reduce_parameters A PdfReduceParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfReduceResponse
     */
    public function reduce($pdf_reduce_parameters)
    {
        list($response) = $this->reduceWithHttpInfo($pdf_reduce_parameters);
        return $response;
    }

    /**
     * Operation reduceWithHttpInfo
     *
     * Reduces the size of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReduceParameters $pdf_reduce_parameters A PdfReduceParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfReduceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function reduceWithHttpInfo($pdf_reduce_parameters)
    {
        $request = $this->reduceRequest($pdf_reduce_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfReduceResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfReduceResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfReduceResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfReduceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reduceAsync
     *
     * Reduces the size of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReduceParameters $pdf_reduce_parameters A PdfReduceParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reduceAsync($pdf_reduce_parameters)
    {
        return $this->reduceAsyncWithHttpInfo($pdf_reduce_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reduceAsyncWithHttpInfo
     *
     * Reduces the size of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReduceParameters $pdf_reduce_parameters A PdfReduceParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reduceAsyncWithHttpInfo($pdf_reduce_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfReduceResponse';
        $request = $this->reduceRequest($pdf_reduce_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reduce'
     *
     * @param  \OpenAPI\Client\Model\PdfReduceParameters $pdf_reduce_parameters A PdfReduceParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reduceRequest($pdf_reduce_parameters)
    {
        // verify the required parameter 'pdf_reduce_parameters' is set
        if ($pdf_reduce_parameters === null || (is_array($pdf_reduce_parameters) && count($pdf_reduce_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_reduce_parameters when calling reduce'
            );
        }

        $resourcePath = '/api/pdf/Reduce';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_reduce_parameters)) {
            $_tempBody = $pdf_reduce_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removePageFormFields
     *
     * Removes the form fields from a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRemovePageFormFieldsParameters $pdf_remove_page_form_fields_parameters A PdfRemovePageFormFieldsParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfRemovePageFormFieldsResponse
     */
    public function removePageFormFields($pdf_remove_page_form_fields_parameters)
    {
        list($response) = $this->removePageFormFieldsWithHttpInfo($pdf_remove_page_form_fields_parameters);
        return $response;
    }

    /**
     * Operation removePageFormFieldsWithHttpInfo
     *
     * Removes the form fields from a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRemovePageFormFieldsParameters $pdf_remove_page_form_fields_parameters A PdfRemovePageFormFieldsParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfRemovePageFormFieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function removePageFormFieldsWithHttpInfo($pdf_remove_page_form_fields_parameters)
    {
        $request = $this->removePageFormFieldsRequest($pdf_remove_page_form_fields_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfRemovePageFormFieldsResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfRemovePageFormFieldsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfRemovePageFormFieldsResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfRemovePageFormFieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removePageFormFieldsAsync
     *
     * Removes the form fields from a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRemovePageFormFieldsParameters $pdf_remove_page_form_fields_parameters A PdfRemovePageFormFieldsParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removePageFormFieldsAsync($pdf_remove_page_form_fields_parameters)
    {
        return $this->removePageFormFieldsAsyncWithHttpInfo($pdf_remove_page_form_fields_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removePageFormFieldsAsyncWithHttpInfo
     *
     * Removes the form fields from a page range of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRemovePageFormFieldsParameters $pdf_remove_page_form_fields_parameters A PdfRemovePageFormFieldsParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removePageFormFieldsAsyncWithHttpInfo($pdf_remove_page_form_fields_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfRemovePageFormFieldsResponse';
        $request = $this->removePageFormFieldsRequest($pdf_remove_page_form_fields_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removePageFormFields'
     *
     * @param  \OpenAPI\Client\Model\PdfRemovePageFormFieldsParameters $pdf_remove_page_form_fields_parameters A PdfRemovePageFormFieldsParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removePageFormFieldsRequest($pdf_remove_page_form_fields_parameters)
    {
        // verify the required parameter 'pdf_remove_page_form_fields_parameters' is set
        if ($pdf_remove_page_form_fields_parameters === null || (is_array($pdf_remove_page_form_fields_parameters) && count($pdf_remove_page_form_fields_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_remove_page_form_fields_parameters when calling removePageFormFields'
            );
        }

        $resourcePath = '/api/pdf/RemovePageFormFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_remove_page_form_fields_parameters)) {
            $_tempBody = $pdf_remove_page_form_fields_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reorderPages
     *
     * Reorders pages of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReorderPagesParameters $pdf_reorder_pages_parameters A PdfReorderPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfReorderPagesResponse
     */
    public function reorderPages($pdf_reorder_pages_parameters)
    {
        list($response) = $this->reorderPagesWithHttpInfo($pdf_reorder_pages_parameters);
        return $response;
    }

    /**
     * Operation reorderPagesWithHttpInfo
     *
     * Reorders pages of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReorderPagesParameters $pdf_reorder_pages_parameters A PdfReorderPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfReorderPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function reorderPagesWithHttpInfo($pdf_reorder_pages_parameters)
    {
        $request = $this->reorderPagesRequest($pdf_reorder_pages_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfReorderPagesResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfReorderPagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfReorderPagesResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfReorderPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reorderPagesAsync
     *
     * Reorders pages of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReorderPagesParameters $pdf_reorder_pages_parameters A PdfReorderPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reorderPagesAsync($pdf_reorder_pages_parameters)
    {
        return $this->reorderPagesAsyncWithHttpInfo($pdf_reorder_pages_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reorderPagesAsyncWithHttpInfo
     *
     * Reorders pages of a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfReorderPagesParameters $pdf_reorder_pages_parameters A PdfReorderPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reorderPagesAsyncWithHttpInfo($pdf_reorder_pages_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfReorderPagesResponse';
        $request = $this->reorderPagesRequest($pdf_reorder_pages_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reorderPages'
     *
     * @param  \OpenAPI\Client\Model\PdfReorderPagesParameters $pdf_reorder_pages_parameters A PdfReorderPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reorderPagesRequest($pdf_reorder_pages_parameters)
    {
        // verify the required parameter 'pdf_reorder_pages_parameters' is set
        if ($pdf_reorder_pages_parameters === null || (is_array($pdf_reorder_pages_parameters) && count($pdf_reorder_pages_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_reorder_pages_parameters when calling reorderPages'
            );
        }

        $resourcePath = '/api/pdf/ReorderPages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_reorder_pages_parameters)) {
            $_tempBody = $pdf_reorder_pages_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation repairDocument
     *
     * Repairs a previously uploaded PDF document.
     *
     * @param  \OpenAPI\Client\Model\PdfRepairDocumentParameters $pdf_repair_document_parameters A PdfRepairDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfRepairDocumentResponse
     */
    public function repairDocument($pdf_repair_document_parameters)
    {
        list($response) = $this->repairDocumentWithHttpInfo($pdf_repair_document_parameters);
        return $response;
    }

    /**
     * Operation repairDocumentWithHttpInfo
     *
     * Repairs a previously uploaded PDF document.
     *
     * @param  \OpenAPI\Client\Model\PdfRepairDocumentParameters $pdf_repair_document_parameters A PdfRepairDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfRepairDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function repairDocumentWithHttpInfo($pdf_repair_document_parameters)
    {
        $request = $this->repairDocumentRequest($pdf_repair_document_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfRepairDocumentResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfRepairDocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfRepairDocumentResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfRepairDocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation repairDocumentAsync
     *
     * Repairs a previously uploaded PDF document.
     *
     * @param  \OpenAPI\Client\Model\PdfRepairDocumentParameters $pdf_repair_document_parameters A PdfRepairDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repairDocumentAsync($pdf_repair_document_parameters)
    {
        return $this->repairDocumentAsyncWithHttpInfo($pdf_repair_document_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation repairDocumentAsyncWithHttpInfo
     *
     * Repairs a previously uploaded PDF document.
     *
     * @param  \OpenAPI\Client\Model\PdfRepairDocumentParameters $pdf_repair_document_parameters A PdfRepairDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repairDocumentAsyncWithHttpInfo($pdf_repair_document_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfRepairDocumentResponse';
        $request = $this->repairDocumentRequest($pdf_repair_document_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'repairDocument'
     *
     * @param  \OpenAPI\Client\Model\PdfRepairDocumentParameters $pdf_repair_document_parameters A PdfRepairDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function repairDocumentRequest($pdf_repair_document_parameters)
    {
        // verify the required parameter 'pdf_repair_document_parameters' is set
        if ($pdf_repair_document_parameters === null || (is_array($pdf_repair_document_parameters) && count($pdf_repair_document_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_repair_document_parameters when calling repairDocument'
            );
        }

        $resourcePath = '/api/pdf/RepairDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_repair_document_parameters)) {
            $_tempBody = $pdf_repair_document_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rotatePageStandard
     *
     * Rotates (standardly) a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRotatePageStandardParameters $pdf_rotate_page_standard_parameters A PdfRotatePageStandardParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfRotatePageStandardResponse
     */
    public function rotatePageStandard($pdf_rotate_page_standard_parameters)
    {
        list($response) = $this->rotatePageStandardWithHttpInfo($pdf_rotate_page_standard_parameters);
        return $response;
    }

    /**
     * Operation rotatePageStandardWithHttpInfo
     *
     * Rotates (standardly) a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRotatePageStandardParameters $pdf_rotate_page_standard_parameters A PdfRotatePageStandardParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfRotatePageStandardResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function rotatePageStandardWithHttpInfo($pdf_rotate_page_standard_parameters)
    {
        $request = $this->rotatePageStandardRequest($pdf_rotate_page_standard_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfRotatePageStandardResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfRotatePageStandardResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfRotatePageStandardResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfRotatePageStandardResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rotatePageStandardAsync
     *
     * Rotates (standardly) a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRotatePageStandardParameters $pdf_rotate_page_standard_parameters A PdfRotatePageStandardParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rotatePageStandardAsync($pdf_rotate_page_standard_parameters)
    {
        return $this->rotatePageStandardAsyncWithHttpInfo($pdf_rotate_page_standard_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rotatePageStandardAsyncWithHttpInfo
     *
     * Rotates (standardly) a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfRotatePageStandardParameters $pdf_rotate_page_standard_parameters A PdfRotatePageStandardParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rotatePageStandardAsyncWithHttpInfo($pdf_rotate_page_standard_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfRotatePageStandardResponse';
        $request = $this->rotatePageStandardRequest($pdf_rotate_page_standard_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rotatePageStandard'
     *
     * @param  \OpenAPI\Client\Model\PdfRotatePageStandardParameters $pdf_rotate_page_standard_parameters A PdfRotatePageStandardParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rotatePageStandardRequest($pdf_rotate_page_standard_parameters)
    {
        // verify the required parameter 'pdf_rotate_page_standard_parameters' is set
        if ($pdf_rotate_page_standard_parameters === null || (is_array($pdf_rotate_page_standard_parameters) && count($pdf_rotate_page_standard_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_rotate_page_standard_parameters when calling rotatePageStandard'
            );
        }

        $resourcePath = '/api/pdf/RotatePageStandard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_rotate_page_standard_parameters)) {
            $_tempBody = $pdf_rotate_page_standard_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsJPEG
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSaveAsJPEGResponse
     */
    public function saveAsJPEG($pdf_save_as_jpeg_parameters)
    {
        list($response) = $this->saveAsJPEGWithHttpInfo($pdf_save_as_jpeg_parameters);
        return $response;
    }

    /**
     * Operation saveAsJPEGWithHttpInfo
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSaveAsJPEGResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsJPEGWithHttpInfo($pdf_save_as_jpeg_parameters)
    {
        $request = $this->saveAsJPEGRequest($pdf_save_as_jpeg_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSaveAsJPEGResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSaveAsJPEGResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSaveAsJPEGResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSaveAsJPEGResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsJPEGAsync
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsJPEGAsync($pdf_save_as_jpeg_parameters)
    {
        return $this->saveAsJPEGAsyncWithHttpInfo($pdf_save_as_jpeg_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsJPEGAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsJPEGAsyncWithHttpInfo($pdf_save_as_jpeg_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSaveAsJPEGResponse';
        $request = $this->saveAsJPEGRequest($pdf_save_as_jpeg_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsJPEG'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsJPEGRequest($pdf_save_as_jpeg_parameters)
    {
        // verify the required parameter 'pdf_save_as_jpeg_parameters' is set
        if ($pdf_save_as_jpeg_parameters === null || (is_array($pdf_save_as_jpeg_parameters) && count($pdf_save_as_jpeg_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_jpeg_parameters when calling saveAsJPEG'
            );
        }

        $resourcePath = '/api/pdf/SaveAsJPEG';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_jpeg_parameters)) {
            $_tempBody = $pdf_save_as_jpeg_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsJPEGFile
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function saveAsJPEGFile($pdf_save_as_jpeg_parameters)
    {
        list($response) = $this->saveAsJPEGFileWithHttpInfo($pdf_save_as_jpeg_parameters);
        return $response;
    }

    /**
     * Operation saveAsJPEGFileWithHttpInfo
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsJPEGFileWithHttpInfo($pdf_save_as_jpeg_parameters)
    {
        $request = $this->saveAsJPEGFileRequest($pdf_save_as_jpeg_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsJPEGFileAsync
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsJPEGFileAsync($pdf_save_as_jpeg_parameters)
    {
        return $this->saveAsJPEGFileAsyncWithHttpInfo($pdf_save_as_jpeg_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsJPEGFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as JPEG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsJPEGFileAsyncWithHttpInfo($pdf_save_as_jpeg_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->saveAsJPEGFileRequest($pdf_save_as_jpeg_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsJPEGFile'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsJPEGParameters $pdf_save_as_jpeg_parameters A PdfSaveAsJPEGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsJPEGFileRequest($pdf_save_as_jpeg_parameters)
    {
        // verify the required parameter 'pdf_save_as_jpeg_parameters' is set
        if ($pdf_save_as_jpeg_parameters === null || (is_array($pdf_save_as_jpeg_parameters) && count($pdf_save_as_jpeg_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_jpeg_parameters when calling saveAsJPEGFile'
            );
        }

        $resourcePath = '/api/pdf/SaveAsJPEGFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_jpeg_parameters)) {
            $_tempBody = $pdf_save_as_jpeg_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsPNG
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSaveAsPNGResponse
     */
    public function saveAsPNG($pdf_save_as_png_parameters)
    {
        list($response) = $this->saveAsPNGWithHttpInfo($pdf_save_as_png_parameters);
        return $response;
    }

    /**
     * Operation saveAsPNGWithHttpInfo
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSaveAsPNGResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsPNGWithHttpInfo($pdf_save_as_png_parameters)
    {
        $request = $this->saveAsPNGRequest($pdf_save_as_png_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSaveAsPNGResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSaveAsPNGResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSaveAsPNGResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSaveAsPNGResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsPNGAsync
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsPNGAsync($pdf_save_as_png_parameters)
    {
        return $this->saveAsPNGAsyncWithHttpInfo($pdf_save_as_png_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsPNGAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsPNGAsyncWithHttpInfo($pdf_save_as_png_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSaveAsPNGResponse';
        $request = $this->saveAsPNGRequest($pdf_save_as_png_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsPNG'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsPNGRequest($pdf_save_as_png_parameters)
    {
        // verify the required parameter 'pdf_save_as_png_parameters' is set
        if ($pdf_save_as_png_parameters === null || (is_array($pdf_save_as_png_parameters) && count($pdf_save_as_png_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_png_parameters when calling saveAsPNG'
            );
        }

        $resourcePath = '/api/pdf/SaveAsPNG';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_png_parameters)) {
            $_tempBody = $pdf_save_as_png_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsPNGFile
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function saveAsPNGFile($pdf_save_as_png_parameters)
    {
        list($response) = $this->saveAsPNGFileWithHttpInfo($pdf_save_as_png_parameters);
        return $response;
    }

    /**
     * Operation saveAsPNGFileWithHttpInfo
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsPNGFileWithHttpInfo($pdf_save_as_png_parameters)
    {
        $request = $this->saveAsPNGFileRequest($pdf_save_as_png_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsPNGFileAsync
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsPNGFileAsync($pdf_save_as_png_parameters)
    {
        return $this->saveAsPNGFileAsyncWithHttpInfo($pdf_save_as_png_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsPNGFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as PNG.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsPNGFileAsyncWithHttpInfo($pdf_save_as_png_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->saveAsPNGFileRequest($pdf_save_as_png_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsPNGFile'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsPNGParameters $pdf_save_as_png_parameters A PdfSaveAsPNGParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsPNGFileRequest($pdf_save_as_png_parameters)
    {
        // verify the required parameter 'pdf_save_as_png_parameters' is set
        if ($pdf_save_as_png_parameters === null || (is_array($pdf_save_as_png_parameters) && count($pdf_save_as_png_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_png_parameters when calling saveAsPNGFile'
            );
        }

        $resourcePath = '/api/pdf/SaveAsPNGFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_png_parameters)) {
            $_tempBody = $pdf_save_as_png_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsTIFF
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSaveAsTIFFResponse
     */
    public function saveAsTIFF($pdf_save_as_tiff_parameters)
    {
        list($response) = $this->saveAsTIFFWithHttpInfo($pdf_save_as_tiff_parameters);
        return $response;
    }

    /**
     * Operation saveAsTIFFWithHttpInfo
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSaveAsTIFFResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsTIFFWithHttpInfo($pdf_save_as_tiff_parameters)
    {
        $request = $this->saveAsTIFFRequest($pdf_save_as_tiff_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSaveAsTIFFResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSaveAsTIFFResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSaveAsTIFFResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSaveAsTIFFResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsTIFFAsync
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFAsync($pdf_save_as_tiff_parameters)
    {
        return $this->saveAsTIFFAsyncWithHttpInfo($pdf_save_as_tiff_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsTIFFAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFAsyncWithHttpInfo($pdf_save_as_tiff_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSaveAsTIFFResponse';
        $request = $this->saveAsTIFFRequest($pdf_save_as_tiff_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsTIFF'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsTIFFRequest($pdf_save_as_tiff_parameters)
    {
        // verify the required parameter 'pdf_save_as_tiff_parameters' is set
        if ($pdf_save_as_tiff_parameters === null || (is_array($pdf_save_as_tiff_parameters) && count($pdf_save_as_tiff_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_tiff_parameters when calling saveAsTIFF'
            );
        }

        $resourcePath = '/api/pdf/SaveAsTIFF';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_tiff_parameters)) {
            $_tempBody = $pdf_save_as_tiff_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsTIFFFile
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function saveAsTIFFFile($pdf_save_as_tiff_parameters)
    {
        list($response) = $this->saveAsTIFFFileWithHttpInfo($pdf_save_as_tiff_parameters);
        return $response;
    }

    /**
     * Operation saveAsTIFFFileWithHttpInfo
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsTIFFFileWithHttpInfo($pdf_save_as_tiff_parameters)
    {
        $request = $this->saveAsTIFFFileRequest($pdf_save_as_tiff_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsTIFFFileAsync
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFFileAsync($pdf_save_as_tiff_parameters)
    {
        return $this->saveAsTIFFFileAsyncWithHttpInfo($pdf_save_as_tiff_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsTIFFFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFFileAsyncWithHttpInfo($pdf_save_as_tiff_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->saveAsTIFFFileRequest($pdf_save_as_tiff_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsTIFFFile'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFParameters $pdf_save_as_tiff_parameters A PdfSaveAsTIFFParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsTIFFFileRequest($pdf_save_as_tiff_parameters)
    {
        // verify the required parameter 'pdf_save_as_tiff_parameters' is set
        if ($pdf_save_as_tiff_parameters === null || (is_array($pdf_save_as_tiff_parameters) && count($pdf_save_as_tiff_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_tiff_parameters when calling saveAsTIFFFile'
            );
        }

        $resourcePath = '/api/pdf/SaveAsTIFFFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_tiff_parameters)) {
            $_tempBody = $pdf_save_as_tiff_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsTIFFMultipage
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageResponse
     */
    public function saveAsTIFFMultipage($pdf_save_as_tiff_multipage_parameters)
    {
        list($response) = $this->saveAsTIFFMultipageWithHttpInfo($pdf_save_as_tiff_multipage_parameters);
        return $response;
    }

    /**
     * Operation saveAsTIFFMultipageWithHttpInfo
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsTIFFMultipageWithHttpInfo($pdf_save_as_tiff_multipage_parameters)
    {
        $request = $this->saveAsTIFFMultipageRequest($pdf_save_as_tiff_multipage_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSaveAsTIFFMultipageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSaveAsTIFFMultipageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSaveAsTIFFMultipageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSaveAsTIFFMultipageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsTIFFMultipageAsync
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFMultipageAsync($pdf_save_as_tiff_multipage_parameters)
    {
        return $this->saveAsTIFFMultipageAsyncWithHttpInfo($pdf_save_as_tiff_multipage_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsTIFFMultipageAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFMultipageAsyncWithHttpInfo($pdf_save_as_tiff_multipage_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSaveAsTIFFMultipageResponse';
        $request = $this->saveAsTIFFMultipageRequest($pdf_save_as_tiff_multipage_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsTIFFMultipage'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsTIFFMultipageRequest($pdf_save_as_tiff_multipage_parameters)
    {
        // verify the required parameter 'pdf_save_as_tiff_multipage_parameters' is set
        if ($pdf_save_as_tiff_multipage_parameters === null || (is_array($pdf_save_as_tiff_multipage_parameters) && count($pdf_save_as_tiff_multipage_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_tiff_multipage_parameters when calling saveAsTIFFMultipage'
            );
        }

        $resourcePath = '/api/pdf/SaveAsTIFFMultipage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_tiff_multipage_parameters)) {
            $_tempBody = $pdf_save_as_tiff_multipage_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveAsTIFFMultipageFile
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function saveAsTIFFMultipageFile($pdf_save_as_tiff_multipage_parameters)
    {
        list($response) = $this->saveAsTIFFMultipageFileWithHttpInfo($pdf_save_as_tiff_multipage_parameters);
        return $response;
    }

    /**
     * Operation saveAsTIFFMultipageFileWithHttpInfo
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveAsTIFFMultipageFileWithHttpInfo($pdf_save_as_tiff_multipage_parameters)
    {
        $request = $this->saveAsTIFFMultipageFileRequest($pdf_save_as_tiff_multipage_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveAsTIFFMultipageFileAsync
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFMultipageFileAsync($pdf_save_as_tiff_multipage_parameters)
    {
        return $this->saveAsTIFFMultipageFileAsyncWithHttpInfo($pdf_save_as_tiff_multipage_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveAsTIFFMultipageFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as multipage TIFF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTIFFMultipageFileAsyncWithHttpInfo($pdf_save_as_tiff_multipage_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->saveAsTIFFMultipageFileRequest($pdf_save_as_tiff_multipage_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveAsTIFFMultipageFile'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveAsTIFFMultipageParameters $pdf_save_as_tiff_multipage_parameters A PdfSaveAsTIFFMultipageParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveAsTIFFMultipageFileRequest($pdf_save_as_tiff_multipage_parameters)
    {
        // verify the required parameter 'pdf_save_as_tiff_multipage_parameters' is set
        if ($pdf_save_as_tiff_multipage_parameters === null || (is_array($pdf_save_as_tiff_multipage_parameters) && count($pdf_save_as_tiff_multipage_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_as_tiff_multipage_parameters when calling saveAsTIFFMultipageFile'
            );
        }

        $resourcePath = '/api/pdf/SaveAsTIFFMultipageFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_as_tiff_multipage_parameters)) {
            $_tempBody = $pdf_save_as_tiff_multipage_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveDocument
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSaveDocumentResponse
     */
    public function saveDocument($pdf_save_document_parameters)
    {
        list($response) = $this->saveDocumentWithHttpInfo($pdf_save_document_parameters);
        return $response;
    }

    /**
     * Operation saveDocumentWithHttpInfo
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSaveDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveDocumentWithHttpInfo($pdf_save_document_parameters)
    {
        $request = $this->saveDocumentRequest($pdf_save_document_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSaveDocumentResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSaveDocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSaveDocumentResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSaveDocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveDocumentAsync
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveDocumentAsync($pdf_save_document_parameters)
    {
        return $this->saveDocumentAsyncWithHttpInfo($pdf_save_document_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveDocumentAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveDocumentAsyncWithHttpInfo($pdf_save_document_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSaveDocumentResponse';
        $request = $this->saveDocumentRequest($pdf_save_document_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveDocument'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveDocumentRequest($pdf_save_document_parameters)
    {
        // verify the required parameter 'pdf_save_document_parameters' is set
        if ($pdf_save_document_parameters === null || (is_array($pdf_save_document_parameters) && count($pdf_save_document_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_document_parameters when calling saveDocument'
            );
        }

        $resourcePath = '/api/pdf/SaveDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_document_parameters)) {
            $_tempBody = $pdf_save_document_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveDocumentToFile
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function saveDocumentToFile($pdf_save_document_parameters)
    {
        list($response) = $this->saveDocumentToFileWithHttpInfo($pdf_save_document_parameters);
        return $response;
    }

    /**
     * Operation saveDocumentToFileWithHttpInfo
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveDocumentToFileWithHttpInfo($pdf_save_document_parameters)
    {
        $request = $this->saveDocumentToFileRequest($pdf_save_document_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveDocumentToFileAsync
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveDocumentToFileAsync($pdf_save_document_parameters)
    {
        return $this->saveDocumentToFileAsyncWithHttpInfo($pdf_save_document_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveDocumentToFileAsyncWithHttpInfo
     *
     * Saves a previously uploaded document as PDF.
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveDocumentToFileAsyncWithHttpInfo($pdf_save_document_parameters)
    {
        $returnType = '\SplFileObject';
        $request = $this->saveDocumentToFileRequest($pdf_save_document_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveDocumentToFile'
     *
     * @param  \OpenAPI\Client\Model\PdfSaveDocumentParameters $pdf_save_document_parameters A PdfSaveDocumentParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveDocumentToFileRequest($pdf_save_document_parameters)
    {
        // verify the required parameter 'pdf_save_document_parameters' is set
        if ($pdf_save_document_parameters === null || (is_array($pdf_save_document_parameters) && count($pdf_save_document_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_save_document_parameters when calling saveDocumentToFile'
            );
        }

        $resourcePath = '/api/pdf/SaveDocumentToFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_save_document_parameters)) {
            $_tempBody = $pdf_save_document_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scalePage
     *
     * Scales a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfScalePageParameters $pdf_scale_page_parameters A PdfScalePage object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfScalePageResponse
     */
    public function scalePage($pdf_scale_page_parameters)
    {
        list($response) = $this->scalePageWithHttpInfo($pdf_scale_page_parameters);
        return $response;
    }

    /**
     * Operation scalePageWithHttpInfo
     *
     * Scales a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfScalePageParameters $pdf_scale_page_parameters A PdfScalePage object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfScalePageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function scalePageWithHttpInfo($pdf_scale_page_parameters)
    {
        $request = $this->scalePageRequest($pdf_scale_page_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfScalePageResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfScalePageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfScalePageResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfScalePageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scalePageAsync
     *
     * Scales a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfScalePageParameters $pdf_scale_page_parameters A PdfScalePage object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scalePageAsync($pdf_scale_page_parameters)
    {
        return $this->scalePageAsyncWithHttpInfo($pdf_scale_page_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scalePageAsyncWithHttpInfo
     *
     * Scales a page range from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfScalePageParameters $pdf_scale_page_parameters A PdfScalePage object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scalePageAsyncWithHttpInfo($pdf_scale_page_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfScalePageResponse';
        $request = $this->scalePageRequest($pdf_scale_page_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scalePage'
     *
     * @param  \OpenAPI\Client\Model\PdfScalePageParameters $pdf_scale_page_parameters A PdfScalePage object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scalePageRequest($pdf_scale_page_parameters)
    {
        // verify the required parameter 'pdf_scale_page_parameters' is set
        if ($pdf_scale_page_parameters === null || (is_array($pdf_scale_page_parameters) && count($pdf_scale_page_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_scale_page_parameters when calling scalePage'
            );
        }

        $resourcePath = '/api/pdf/ScalePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_scale_page_parameters)) {
            $_tempBody = $pdf_scale_page_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setInfo
     *
     * Sets information to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInfoParameters $pdf_set_info_parameters A PdfSetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSetInfoResponse
     */
    public function setInfo($pdf_set_info_parameters)
    {
        list($response) = $this->setInfoWithHttpInfo($pdf_set_info_parameters);
        return $response;
    }

    /**
     * Operation setInfoWithHttpInfo
     *
     * Sets information to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInfoParameters $pdf_set_info_parameters A PdfSetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSetInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setInfoWithHttpInfo($pdf_set_info_parameters)
    {
        $request = $this->setInfoRequest($pdf_set_info_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSetInfoResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSetInfoResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSetInfoResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSetInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setInfoAsync
     *
     * Sets information to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInfoParameters $pdf_set_info_parameters A PdfSetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setInfoAsync($pdf_set_info_parameters)
    {
        return $this->setInfoAsyncWithHttpInfo($pdf_set_info_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setInfoAsyncWithHttpInfo
     *
     * Sets information to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInfoParameters $pdf_set_info_parameters A PdfSetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setInfoAsyncWithHttpInfo($pdf_set_info_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSetInfoResponse';
        $request = $this->setInfoRequest($pdf_set_info_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setInfo'
     *
     * @param  \OpenAPI\Client\Model\PdfSetInfoParameters $pdf_set_info_parameters A PdfSetInfoParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setInfoRequest($pdf_set_info_parameters)
    {
        // verify the required parameter 'pdf_set_info_parameters' is set
        if ($pdf_set_info_parameters === null || (is_array($pdf_set_info_parameters) && count($pdf_set_info_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_set_info_parameters when calling setInfo'
            );
        }

        $resourcePath = '/api/pdf/SetInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_set_info_parameters)) {
            $_tempBody = $pdf_set_info_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setInitialView
     *
     * Sets various document level initial view options to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInitialViewParameters $pdf_set_initial_view_parameters A PdfsetInitialViewParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSetInitialViewResponse
     */
    public function setInitialView($pdf_set_initial_view_parameters)
    {
        list($response) = $this->setInitialViewWithHttpInfo($pdf_set_initial_view_parameters);
        return $response;
    }

    /**
     * Operation setInitialViewWithHttpInfo
     *
     * Sets various document level initial view options to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInitialViewParameters $pdf_set_initial_view_parameters A PdfsetInitialViewParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSetInitialViewResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setInitialViewWithHttpInfo($pdf_set_initial_view_parameters)
    {
        $request = $this->setInitialViewRequest($pdf_set_initial_view_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSetInitialViewResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSetInitialViewResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSetInitialViewResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSetInitialViewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setInitialViewAsync
     *
     * Sets various document level initial view options to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInitialViewParameters $pdf_set_initial_view_parameters A PdfsetInitialViewParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setInitialViewAsync($pdf_set_initial_view_parameters)
    {
        return $this->setInitialViewAsyncWithHttpInfo($pdf_set_initial_view_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setInitialViewAsyncWithHttpInfo
     *
     * Sets various document level initial view options to a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetInitialViewParameters $pdf_set_initial_view_parameters A PdfsetInitialViewParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setInitialViewAsyncWithHttpInfo($pdf_set_initial_view_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSetInitialViewResponse';
        $request = $this->setInitialViewRequest($pdf_set_initial_view_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setInitialView'
     *
     * @param  \OpenAPI\Client\Model\PdfSetInitialViewParameters $pdf_set_initial_view_parameters A PdfsetInitialViewParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setInitialViewRequest($pdf_set_initial_view_parameters)
    {
        // verify the required parameter 'pdf_set_initial_view_parameters' is set
        if ($pdf_set_initial_view_parameters === null || (is_array($pdf_set_initial_view_parameters) && count($pdf_set_initial_view_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_set_initial_view_parameters when calling setInitialView'
            );
        }

        $resourcePath = '/api/pdf/SetInitialView';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_set_initial_view_parameters)) {
            $_tempBody = $pdf_set_initial_view_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPageBox
     *
     * Sets pagebox to a page range from previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPageBoxParameters $pdf_set_page_box_parameters A PdfSetPageBoxParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSetPageBoxResponse
     */
    public function setPageBox($pdf_set_page_box_parameters)
    {
        list($response) = $this->setPageBoxWithHttpInfo($pdf_set_page_box_parameters);
        return $response;
    }

    /**
     * Operation setPageBoxWithHttpInfo
     *
     * Sets pagebox to a page range from previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPageBoxParameters $pdf_set_page_box_parameters A PdfSetPageBoxParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSetPageBoxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setPageBoxWithHttpInfo($pdf_set_page_box_parameters)
    {
        $request = $this->setPageBoxRequest($pdf_set_page_box_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSetPageBoxResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSetPageBoxResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSetPageBoxResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSetPageBoxResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setPageBoxAsync
     *
     * Sets pagebox to a page range from previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPageBoxParameters $pdf_set_page_box_parameters A PdfSetPageBoxParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPageBoxAsync($pdf_set_page_box_parameters)
    {
        return $this->setPageBoxAsyncWithHttpInfo($pdf_set_page_box_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPageBoxAsyncWithHttpInfo
     *
     * Sets pagebox to a page range from previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPageBoxParameters $pdf_set_page_box_parameters A PdfSetPageBoxParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPageBoxAsyncWithHttpInfo($pdf_set_page_box_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSetPageBoxResponse';
        $request = $this->setPageBoxRequest($pdf_set_page_box_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPageBox'
     *
     * @param  \OpenAPI\Client\Model\PdfSetPageBoxParameters $pdf_set_page_box_parameters A PdfSetPageBoxParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setPageBoxRequest($pdf_set_page_box_parameters)
    {
        // verify the required parameter 'pdf_set_page_box_parameters' is set
        if ($pdf_set_page_box_parameters === null || (is_array($pdf_set_page_box_parameters) && count($pdf_set_page_box_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_set_page_box_parameters when calling setPageBox'
            );
        }

        $resourcePath = '/api/pdf/SetPageBox';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_set_page_box_parameters)) {
            $_tempBody = $pdf_set_page_box_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPassword
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPasswordParameters $pdf_set_password_parameters A PdfSetPasswordParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSetPasswordResponse
     */
    public function setPassword($pdf_set_password_parameters)
    {
        list($response) = $this->setPasswordWithHttpInfo($pdf_set_password_parameters);
        return $response;
    }

    /**
     * Operation setPasswordWithHttpInfo
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPasswordParameters $pdf_set_password_parameters A PdfSetPasswordParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSetPasswordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setPasswordWithHttpInfo($pdf_set_password_parameters)
    {
        $request = $this->setPasswordRequest($pdf_set_password_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSetPasswordResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSetPasswordResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSetPasswordResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSetPasswordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setPasswordAsync
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPasswordParameters $pdf_set_password_parameters A PdfSetPasswordParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPasswordAsync($pdf_set_password_parameters)
    {
        return $this->setPasswordAsyncWithHttpInfo($pdf_set_password_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPasswordAsyncWithHttpInfo
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSetPasswordParameters $pdf_set_password_parameters A PdfSetPasswordParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPasswordAsyncWithHttpInfo($pdf_set_password_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSetPasswordResponse';
        $request = $this->setPasswordRequest($pdf_set_password_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPassword'
     *
     * @param  \OpenAPI\Client\Model\PdfSetPasswordParameters $pdf_set_password_parameters A PdfSetPasswordParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setPasswordRequest($pdf_set_password_parameters)
    {
        // verify the required parameter 'pdf_set_password_parameters' is set
        if ($pdf_set_password_parameters === null || (is_array($pdf_set_password_parameters) && count($pdf_set_password_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_set_password_parameters when calling setPassword'
            );
        }

        $resourcePath = '/api/pdf/SetPassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_set_password_parameters)) {
            $_tempBody = $pdf_set_password_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation split
     *
     * Splits a previously uploaded document into new ones.
     *
     * @param  \OpenAPI\Client\Model\PdfSplitParameters $pdf_split_parameters A PdfSplitParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSplitResponse
     */
    public function split($pdf_split_parameters)
    {
        list($response) = $this->splitWithHttpInfo($pdf_split_parameters);
        return $response;
    }

    /**
     * Operation splitWithHttpInfo
     *
     * Splits a previously uploaded document into new ones.
     *
     * @param  \OpenAPI\Client\Model\PdfSplitParameters $pdf_split_parameters A PdfSplitParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSplitResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function splitWithHttpInfo($pdf_split_parameters)
    {
        $request = $this->splitRequest($pdf_split_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSplitResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSplitResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSplitResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSplitResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation splitAsync
     *
     * Splits a previously uploaded document into new ones.
     *
     * @param  \OpenAPI\Client\Model\PdfSplitParameters $pdf_split_parameters A PdfSplitParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitAsync($pdf_split_parameters)
    {
        return $this->splitAsyncWithHttpInfo($pdf_split_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation splitAsyncWithHttpInfo
     *
     * Splits a previously uploaded document into new ones.
     *
     * @param  \OpenAPI\Client\Model\PdfSplitParameters $pdf_split_parameters A PdfSplitParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitAsyncWithHttpInfo($pdf_split_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSplitResponse';
        $request = $this->splitRequest($pdf_split_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'split'
     *
     * @param  \OpenAPI\Client\Model\PdfSplitParameters $pdf_split_parameters A PdfSplitParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function splitRequest($pdf_split_parameters)
    {
        // verify the required parameter 'pdf_split_parameters' is set
        if ($pdf_split_parameters === null || (is_array($pdf_split_parameters) && count($pdf_split_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_split_parameters when calling split'
            );
        }

        $resourcePath = '/api/pdf/Split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_split_parameters)) {
            $_tempBody = $pdf_split_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swapPages
     *
     * Swaps two pages from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSwapPagesParameters $pdf_swap_pages_parameters A PdfSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfSwapPagesResponse
     */
    public function swapPages($pdf_swap_pages_parameters)
    {
        list($response) = $this->swapPagesWithHttpInfo($pdf_swap_pages_parameters);
        return $response;
    }

    /**
     * Operation swapPagesWithHttpInfo
     *
     * Swaps two pages from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSwapPagesParameters $pdf_swap_pages_parameters A PdfSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfSwapPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function swapPagesWithHttpInfo($pdf_swap_pages_parameters)
    {
        $request = $this->swapPagesRequest($pdf_swap_pages_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfSwapPagesResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfSwapPagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfSwapPagesResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfSwapPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation swapPagesAsync
     *
     * Swaps two pages from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSwapPagesParameters $pdf_swap_pages_parameters A PdfSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapPagesAsync($pdf_swap_pages_parameters)
    {
        return $this->swapPagesAsyncWithHttpInfo($pdf_swap_pages_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swapPagesAsyncWithHttpInfo
     *
     * Swaps two pages from a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfSwapPagesParameters $pdf_swap_pages_parameters A PdfSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapPagesAsyncWithHttpInfo($pdf_swap_pages_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfSwapPagesResponse';
        $request = $this->swapPagesRequest($pdf_swap_pages_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swapPages'
     *
     * @param  \OpenAPI\Client\Model\PdfSwapPagesParameters $pdf_swap_pages_parameters A PdfSwapPagesParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swapPagesRequest($pdf_swap_pages_parameters)
    {
        // verify the required parameter 'pdf_swap_pages_parameters' is set
        if ($pdf_swap_pages_parameters === null || (is_array($pdf_swap_pages_parameters) && count($pdf_swap_pages_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_swap_pages_parameters when calling swapPages'
            );
        }

        $resourcePath = '/api/pdf/SwapPages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_swap_pages_parameters)) {
            $_tempBody = $pdf_swap_pages_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unprotect
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfUnprotectParameters $pdf_unprotect_parameters A PdfUnprotectParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PdfUnprotectResponse
     */
    public function unprotect($pdf_unprotect_parameters)
    {
        list($response) = $this->unprotectWithHttpInfo($pdf_unprotect_parameters);
        return $response;
    }

    /**
     * Operation unprotectWithHttpInfo
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfUnprotectParameters $pdf_unprotect_parameters A PdfUnprotectParameters object specifying the parameters of the action. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PdfUnprotectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function unprotectWithHttpInfo($pdf_unprotect_parameters)
    {
        $request = $this->unprotectRequest($pdf_unprotect_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PdfUnprotectResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PdfUnprotectResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PdfUnprotectResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PdfUnprotectResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unprotectAsync
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfUnprotectParameters $pdf_unprotect_parameters A PdfUnprotectParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unprotectAsync($pdf_unprotect_parameters)
    {
        return $this->unprotectAsyncWithHttpInfo($pdf_unprotect_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unprotectAsyncWithHttpInfo
     *
     * Unprotects a previously uploaded document.
     *
     * @param  \OpenAPI\Client\Model\PdfUnprotectParameters $pdf_unprotect_parameters A PdfUnprotectParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unprotectAsyncWithHttpInfo($pdf_unprotect_parameters)
    {
        $returnType = '\OpenAPI\Client\Model\PdfUnprotectResponse';
        $request = $this->unprotectRequest($pdf_unprotect_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unprotect'
     *
     * @param  \OpenAPI\Client\Model\PdfUnprotectParameters $pdf_unprotect_parameters A PdfUnprotectParameters object specifying the parameters of the action. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function unprotectRequest($pdf_unprotect_parameters)
    {
        // verify the required parameter 'pdf_unprotect_parameters' is set
        if ($pdf_unprotect_parameters === null || (is_array($pdf_unprotect_parameters) && count($pdf_unprotect_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_unprotect_parameters when calling unprotect'
            );
        }

        $resourcePath = '/api/pdf/Unprotect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pdf_unprotect_parameters)) {
            $_tempBody = $pdf_unprotect_parameters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
